<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial on the foundations · SnoopCompile</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SnoopCompile</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><a class="tocitem" href="../snoop_pc/">SnoopPrecompile</a></li><li class="is-active"><a class="tocitem" href>Tutorial on the foundations</a><ul class="internal"><li><a class="tocitem" href="#Cut-to-the-Chase:-A-copy-paste-analysis-of-invalidations"><span>Cut to the Chase: A copy-paste analysis of invalidations</span></a></li><li><a class="tocitem" href="#MethodInstances,-type-inference,-and-backedges"><span><code>MethodInstance</code>s, type-inference, and backedges</span></a></li><li><a class="tocitem" href="#Precompilation"><span>Precompilation</span></a></li></ul></li><li><span class="tocitem">Modern tools</span><ul><li><a class="tocitem" href="../snoopr/">Snooping on and fixing invalidations: <code>@snoopr</code></a></li><li><a class="tocitem" href="../snoopi_deep/">Snooping on inference: <code>@snoopi_deep</code></a></li><li><a class="tocitem" href="../pgdsgui/">Profile-guided despecialization</a></li><li><a class="tocitem" href="../snoopi_deep_analysis/">Using <code>@snoopi_deep</code> results to improve inferrability</a></li><li><a class="tocitem" href="../snoopi_deep_parcel/">Using <code>@snoopi_deep</code> results for precompilation</a></li><li><a class="tocitem" href="../jet/">JET integration</a></li></ul></li><li><span class="tocitem">Older tools</span><ul><li><a class="tocitem" href="../snoopi/">Snooping on inference: <code>@snoopi</code></a></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li></ul></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial on the foundations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial on the foundations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial"><a class="docs-heading-anchor" href="#tutorial">Tutorial on the foundations</a><a id="tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial" title="Permalink"></a></h1><p>Certain concepts and types will appear repeatedly, so it&#39;s worth spending a little time to familiarize yourself at the outset. You can find a more expansive version of this page in <a href="https://julialang.org/blog/2021/01/precompile_tutorial/">this blog post</a>.</p><h2 id="Cut-to-the-Chase:-A-copy-paste-analysis-of-invalidations"><a class="docs-heading-anchor" href="#Cut-to-the-Chase:-A-copy-paste-analysis-of-invalidations">Cut to the Chase: A copy-paste analysis of invalidations</a><a id="Cut-to-the-Chase:-A-copy-paste-analysis-of-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Cut-to-the-Chase:-A-copy-paste-analysis-of-invalidations" title="Permalink"></a></h2><p>The following is a quick &quot;grab and go&quot; script for analyzing invalidations. Insert package loads (<code>using</code> or <code>import</code> statements) and/or method definitions into the <code>@snoopr</code> block, and put the workload you want to be fast in the <code>@snoopi_deep</code> block. The resulting plot shows the distribution of the invalidations sorted by the number of children affected. Generally, invalidations with many children matter more than those with few children, and thus this shows how many &quot;bad actors&quot; need to be investigated. <code>show(trees[end])</code> show the method which leads to the most invalidations, with <code>show(trees[end-1])</code> being the second most, and so forth. While the plot shows total invalidations (<code>trees</code>), only the ones in <code>staletrees</code> affect the workload in <code>@snoopi_deep</code>.</p><pre><code class="language-julia hljs">using SnoopCompileCore
invalidations = @snoopr using PkgA, PkgB;
tinf = @snoopi_deep begin
    some_workload()
end
using SnoopCompile
trees = invalidation_trees(invalidations)
staletrees = precompile_blockers(trees, tinf)

@show length(uinvalidated(invalidations))  # show total invalidations

show(trees[end])  # show the most invalidating method

# Count number of children (number of invalidations per invalidated method)
n_invalidations = map(SnoopCompile.countchildren, trees)

# (optional) plot the number of children per method invalidations
import Plots
Plots.plot(
    1:length(trees),
    n_invalidations;
    markershape=:circle,
    xlabel=&quot;i-th method invalidation&quot;,
    label=&quot;Number of children per method invalidations&quot;
)

# (optional) report invalidations summary
using PrettyTables  # needed for `report_invalidations` to be defined
SnoopCompile.report_invalidations(;
     invalidations,
     process_filename = x -&gt; last(split(x, &quot;.julia/packages/&quot;)),
     n_rows = 0,  # no-limit (show all invalidations)
  )</code></pre><h2 id="MethodInstances,-type-inference,-and-backedges"><a class="docs-heading-anchor" href="#MethodInstances,-type-inference,-and-backedges"><code>MethodInstance</code>s, type-inference, and backedges</a><a id="MethodInstances,-type-inference,-and-backedges-1"></a><a class="docs-heading-anchor-permalink" href="#MethodInstances,-type-inference,-and-backedges" title="Permalink"></a></h2><p>Our first goal is to understand how code connects together. We&#39;ll try some experiments using the following:</p><pre><code class="language-julia hljs">double(x::Real) = 2x
calldouble(container) = double(container[1])
calldouble2(container) = calldouble(container)</code></pre><p>Let&#39;s create a <code>container</code> and run this code:</p><pre><code class="language-julia-repl hljs">julia&gt; c64 = [1.0]
1-element Vector{Float64}:
 1.0

julia&gt; calldouble2(c64)
2.0</code></pre><p>Using the <a href="https://github.com/timholy/MethodAnalysis.jl">MethodAnalysis</a> package, we can get some insights into how Julia represents this code and its compilation dependencies:</p><pre><code class="language-julia-repl hljs">julia&gt; using MethodAnalysis

julia&gt; mi = methodinstance(double, (Float64,))
MethodInstance for double(::Float64)

julia&gt; using AbstractTrees

julia&gt; print_tree(mi)
MethodInstance for double(::Float64)
└─ MethodInstance for calldouble(::Vector{Float64})
   └─ MethodInstance for calldouble2(::Vector{Float64})</code></pre><p>This indicates that the result for type-inference on <code>calldouble2(::Vector{Float64})</code> depended on the result for <code>calldouble(::Vector{Float64})</code>, which in turn depended on <code>double(::Float64)</code>.</p><p>Now let&#39;s create a new container, one with abstract element type, so that Julia&#39;s type-inference cannot accurately predict the type of elements in the container:</p><pre><code class="language-julia-repl hljs">julia&gt; cabs = AbstractFloat[1.0f0]      # put a Float32 in a Vector{AbstractFloat}
1-element Vector{AbstractFloat}:
 1.0f0

julia&gt; calldouble2(cabs)
2.0f0</code></pre><p>Now let&#39;s look at the available instances:</p><pre><code class="language-julia-repl hljs">julia&gt; mis = methodinstances(double)
3-element Vector{Core.MethodInstance}:
 MethodInstance for double(::Float64)
 MethodInstance for double(::AbstractFloat)
 MethodInstance for double(::Float32)

julia&gt; print_tree(mis[1])
MethodInstance for double(::Float64)
└─ MethodInstance for calldouble(::Vector{Float64})
   └─ MethodInstance for calldouble2(::Vector{Float64})

julia&gt; print_tree(mis[2])
MethodInstance for double(::AbstractFloat)

julia&gt; print_tree(mis[3])
MethodInstance for double(::Float32)</code></pre><p><code>double(::Float64)</code> has backedges to <code>calldouble</code> and <code>calldouble2</code>, but the second two do not because <code>double</code> was only called via runtime dispatch. However, <code>calldouble</code> has backedges to <code>calldouble2</code></p><pre><code class="language-julia hljs">julia&gt; mis = methodinstances(calldouble)
2-element Vector{Core.MethodInstance}:
 MethodInstance for calldouble(::Vector{Float64})
 MethodInstance for calldouble(::Vector{AbstractFloat})

julia&gt; print_tree(mis[1])
MethodInstance for calldouble(::Vector{Float64})
└─ MethodInstance for calldouble2(::Vector{Float64})

julia&gt; print_tree(mis[2])
MethodInstance for calldouble(::Vector{AbstractFloat})
└─ MethodInstance for calldouble2(::Vector{AbstractFloat})</code></pre><p>because <code>Vector{AbstractFloat}</code> is a concrete type, whereas <code>AbstractFloat</code> is not.</p><p>If we create <code>c32 = [1.0f0]</code> and then <code>calldouble2(c32)</code>, we would also see backedges from <code>double(::Float32)</code> all the way back to <code>calldouble2(::Vector{Float32})</code>.</p><h2 id="Precompilation"><a class="docs-heading-anchor" href="#Precompilation">Precompilation</a><a id="Precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Precompilation" title="Permalink"></a></h2><p>During <em>package precompilation</em>, Julia creates a <code>*.ji</code> file typically stored in <code>.julia/compiled/v1.x/</code>, where <code>1.x</code> is your version of Julia. Your <code>*.ji</code> file might just have definitions of constants, types, and methods, but optionally you can also include the results of type-inference. This happens automatically if you run code while your package is being built, but generally the recommended procedure is to add <em>precompile directives</em>.</p><p>Let&#39;s turn the example above into a package. In a fresh session,</p><pre><code class="language-julia hljs">(@v1.6) pkg&gt; generate SnoopCompileDemo
  Generating  project SnoopCompileDemo:
    SnoopCompileDemo/Project.toml
    SnoopCompileDemo/src/SnoopCompileDemo.jl

julia&gt; open(&quot;SnoopCompileDemo/src/SnoopCompileDemo.jl&quot;, &quot;w&quot;) do io
           write(io, &quot;&quot;&quot;
           module SnoopCompileDemo

           double(x::Real) = 2x
           calldouble(container) = double(container[1])
           calldouble2(container) = calldouble(container)

           precompile(calldouble2, (Vector{Float32},))
           precompile(calldouble2, (Vector{Float64},))
           precompile(calldouble2, (Vector{AbstractFloat},))

           end
           &quot;&quot;&quot;)
       end
282

julia&gt; push!(LOAD_PATH, &quot;SnoopCompileDemo/&quot;)
4-element Vector{String}:
 &quot;@&quot;
 &quot;@v#.#&quot;
 &quot;@stdlib&quot;
 &quot;SnoopCompileDemo/&quot;

julia&gt; using SnoopCompileDemo
[ Info: Precompiling SnoopCompileDemo [44c70eed-03a3-46c0-8383-afc033fb6a27]

julia&gt; using MethodAnalysis

julia&gt; methodinstances(SnoopCompileDemo.double)
3-element Vector{Core.MethodInstance}:
 MethodInstance for double(::Float32)
 MethodInstance for double(::Float64)
 MethodInstance for double(::AbstractFloat)</code></pre><p>Because of those <code>precompile</code> statements, the <code>MethodInstance</code>s exist after loading the package even though we haven&#39;t run the code in this session–not because it precompiled them when the package loaded, but because they were precompiled during the <code>Precompiling SnoopCompileDemo...</code> phase, stored to <code>*.ji</code> file, and then reloaded whenever we use the package. You can also verify that the same backedges get created as when we ran this code interactively above.</p><p>By having these <code>MethodInstance</code>s &quot;pre-loaded&quot; we can save some of the time needed to run type-inference: not much time in this case because the code is so simple, but for more complex methods the savings can be substantial.</p><p>This code got cached in <code>SnoopCompileDemo.ji</code>. It&#39;s worth noting that even though the <code>precompile</code> directive got issued from this package, it might save <code>MethodInstances</code> for methods defined in other packages. For example, Julia does not come pre-built with the inferred code for <code>Int * Float32</code>: in a fresh session,</p><pre><code class="language-julia hljs">julia&gt; using MethodAnalysis

julia&gt; mi = methodinstance(*, (Int, Float32))
</code></pre><p>returns <code>nothing</code> (the <code>MethodInstance</code> doesn&#39;t exist), whereas if we&#39;ve loaded <code>SnoopCompileDemo</code> then</p><pre><code class="language-julia hljs">julia&gt; mi = methodinstance(*, (Int, Float32))
MethodInstance for *(::Int64, ::Float32)

julia&gt; mi.def
*(x::Number, y::Number) in Base at promotion.jl:322</code></pre><p>So even though the method is defined in <code>Base</code>, because <code>SnoopCompileDemo</code> needed this code it got stashed in <code>SnoopCompileDemo.ji</code>.</p><p><em>The ability to cache <code>MethodInstance</code>s from code defined in other packages or libraries is fundamental to latency reduction; however, it has significant limitations.</em>  Most crucially, <code>*.ji</code> files can only hold code they &quot;own,&quot; either:</p><ul><li>to a method defined in the package</li><li>through a chain of backedges to methods owned by the package</li></ul><p>If we add</p><pre><code class="language-julia hljs">precompile(*, (Int, Float16))</code></pre><p>to the definition of <code>SnoopCompileDemo.jl</code>, nothing happens:</p><pre><code class="language-julia hljs">julia&gt; mi = methodinstance(*, (Int, Float16))
                                                 # nothing</code></pre><p>because there is no &quot;chain of ownership&quot; to <code>SnoopCompileDemo</code>. Consequently, we can&#39;t precompile methods defined in other modules in and of themselves; we can only do it if those methods are linked by backedges to this package.</p><p>Because backedges are created during successful type-inference, the consequence is that <em>precompilation works better when type inference succeeds.</em> For some packages, time invested in improving inferrability can make your <code>precompile</code> directives work better.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../snoop_pc/">« SnoopPrecompile</a><a class="docs-footer-nextpage" href="../snoopr/">Snooping on and fixing invalidations: <code>@snoopr</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 18 March 2023 22:27">Saturday 18 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
