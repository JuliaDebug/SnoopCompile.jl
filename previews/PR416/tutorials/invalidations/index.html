<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial on @snoop_invalidations · SnoopCompile</title><meta name="title" content="Tutorial on @snoop_invalidations · SnoopCompile"/><meta property="og:title" content="Tutorial on @snoop_invalidations · SnoopCompile"/><meta property="twitter:title" content="Tutorial on @snoop_invalidations · SnoopCompile"/><meta name="description" content="Documentation for SnoopCompile."/><meta property="og:description" content="Documentation for SnoopCompile."/><meta property="twitter:description" content="Documentation for SnoopCompile."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SnoopCompile</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SnoopCompile.jl</a></li><li><span class="tocitem">Basic tutorials</span><ul><li class="is-active"><a class="tocitem" href>Tutorial on <code>@snoop_invalidations</code></a><ul class="internal"><li><a class="tocitem" href="#What-are-invalidations?"><span>What are invalidations?</span></a></li><li><a class="tocitem" href="#Learning-to-observe,-diagnose,-and-fix-invalidations"><span>Learning to observe, diagnose, and fix invalidations</span></a></li></ul></li><li><a class="tocitem" href="../snoop_inference/">Tutorial on <code>@snoop_inference</code></a></li><li><a class="tocitem" href="../snoop_llvm/">Tutorial on <code>@snoop_llvm</code></a></li><li><a class="tocitem" href="../pgdsgui/">Profile-guided despecialization</a></li><li><a class="tocitem" href="../jet/">Tutorial on JET integration</a></li></ul></li><li><span class="tocitem">Advanced tutorials</span><ul><li><a class="tocitem" href="../snoop_inference_analysis/">Using <code>@snoop_inference</code> results to improve inferrability</a></li><li><a class="tocitem" href="../snoop_inference_parcel/">Using <code>@snoop_inference</code> to emit manual precompile directives</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../explanations/tools/">Package roles and alternatives</a></li><li><a class="tocitem" href="../../explanations/gotchas/">Precompilation &quot;gotcha&quot;s</a></li><li><a class="tocitem" href="../../explanations/fixing_inference/">Techniques for fixing inference problems</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basic tutorials</a></li><li class="is-active"><a href>Tutorial on <code>@snoop_invalidations</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial on <code>@snoop_invalidations</code></a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/tutorials/invalidations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-on-@snoop_invalidations"><a class="docs-heading-anchor" href="#Tutorial-on-@snoop_invalidations">Tutorial on <code>@snoop_invalidations</code></a><a id="Tutorial-on-@snoop_invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-on-@snoop_invalidations" title="Permalink"></a></h1><h2 id="What-are-invalidations?"><a class="docs-heading-anchor" href="#What-are-invalidations?">What are invalidations?</a><a id="What-are-invalidations?-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-invalidations?" title="Permalink"></a></h2><p>In this context, <em>invalidation</em> means discarding previously-compiled code. Invalidations occur because of interactions between independent pieces of code. Invalidations are essential to make Julia fast, interactive, and correct: you <em>need</em> invalidations if you want to be able to define some methods, run (compile) some code, and then in the same session define new methods that might lead to different answers if you were to recompile the code in the presence of the new methods.</p><p>Invalidations can happen just from loading packages. Packages are precompiled in isolation, but you can load many packages into a single interactive session. It&#39;s impossible for the individual packages to anticipate the full &quot;world of methods&quot; in your interactive session, so sometimes Julia has to discard code that was compiled in a smaller world because it&#39;s at risk for being incorrect in the larger world.</p><p>The downside of invalidations is that they make latency worse, as code must be recompiled when you first run it. The benefits of precompilation are partially lost, and the work done during precompilation is partially wasted.</p><p>While some invalidations are unavoidable, in practice a good developer can often design packages to minimize the number and/or impact of invalidations. Invalidation-resistant code is often faster, with smaller binary size, than code that is vulnerable to invalidation.</p><p>A good first step is to measure what&#39;s being invalidated, and why.</p><h2 id="Learning-to-observe,-diagnose,-and-fix-invalidations"><a class="docs-heading-anchor" href="#Learning-to-observe,-diagnose,-and-fix-invalidations">Learning to observe, diagnose, and fix invalidations</a><a id="Learning-to-observe,-diagnose,-and-fix-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Learning-to-observe,-diagnose,-and-fix-invalidations" title="Permalink"></a></h2><p>We&#39;ll illustrate invalidations by creating two packages, where loading the second package invalidates some code that was compiled in the first one. We&#39;ll then go over approaches for &quot;fixing&quot; invalidations (i.e., preventing them from occuring).</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Since SnoopCompile&#39;s tools are interactive, you are strongly encouraged to try these examples yourself as you read along.</p></div></div><h3 id="Add-SnoopCompileCore,-SnoopCompile,-and-helper-packages-to-your-environment"><a class="docs-heading-anchor" href="#Add-SnoopCompileCore,-SnoopCompile,-and-helper-packages-to-your-environment">Add SnoopCompileCore, SnoopCompile, and helper packages to your environment</a><a id="Add-SnoopCompileCore,-SnoopCompile,-and-helper-packages-to-your-environment-1"></a><a class="docs-heading-anchor-permalink" href="#Add-SnoopCompileCore,-SnoopCompile,-and-helper-packages-to-your-environment" title="Permalink"></a></h3><p>Here, we&#39;ll add these packages to your <a href="https://pkgdocs.julialang.org/v1/environments/">default environment</a>. (With the exception of <code>AbstractTrees</code>, these &quot;developer tool&quot; packages should not be added to the Project file of any real packages unless you&#39;re extending the tool itself.) From your default environment (i.e., in package mode you should see something like <code>(@v1.10) pkg&gt;</code>), do</p><pre><code class="nohighlight hljs">using Pkg
Pkg.add([&quot;SnoopCompileCore&quot;, &quot;SnoopCompile&quot;, &quot;AbstractTrees&quot;, &quot;Cthulhu&quot;]);</code></pre><h3 id="Create-the-demonstration-packages"><a class="docs-heading-anchor" href="#Create-the-demonstration-packages">Create the demonstration packages</a><a id="Create-the-demonstration-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Create-the-demonstration-packages" title="Permalink"></a></h3><p>We&#39;re going to implement a toy version of the card game <a href="https://www.wikihow.com/Play-Blackjack">blackjack</a>, where players take cards with the aim of collecting 21 points. The higher you go the better, <em>unless</em> you go over 21 points, in which case you &quot;go bust&quot; (i.e., you lose). Because our real goal is to illustrate invalidations, we&#39;ll create a &quot;blackjack ecosystem&quot; that involves an interaction between two packages.</p><p>While <a href="https://github.com/JuliaCI/PkgTemplates.jl">PkgTemplates</a> is recommended for creating packages, here we&#39;ll just use the basic capabilities in <code>Pkg</code>. To create the (empty) packages, the code below executes the following steps:</p><ul><li>navigate to a temporary directory and create both packages</li><li>make the first package (<code>Blackjack</code>) depend on <a href="https://github.com/JuliaLang/PrecompileTools.jl">PrecompileTools</a> (we&#39;re interested in reducing latency!)</li><li>make the second package (<code>BlackjackFacecards</code>) depend on the first one (<code>Blackjack</code>)</li></ul><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cd(mktempdir())</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Pkg</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.generate(&quot;Blackjack&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">  Generating</span></span>  project Blackjack:
    Blackjack/Project.toml
    Blackjack/src/Blackjack.jl</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.activate(&quot;Blackjack&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">  Activating</span></span> project at `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/Blackjack`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.add(&quot;PrecompileTools&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">    Updating</span></span> registry at `~/.julia/registries/General.toml`
<span class="sgr32"><span class="sgr1">   Resolving</span></span> package versions...
<span class="sgr32"><span class="sgr1">      Compat</span></span> entries added for PrecompileTools
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/Blackjack/Project.toml`
<span class="sgr33">⌅</span> <span class="sgr90">[aea7be01] </span><span class="sgr92">+ PrecompileTools v1.2.1</span>
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/Blackjack/Manifest.toml`
<span class="sgr33">⌅</span> <span class="sgr90">[aea7be01] </span><span class="sgr92">+ PrecompileTools v1.2.1</span>
  <span class="sgr90">[21216c6a] </span><span class="sgr92">+ Preferences v1.4.3</span>
  <span class="sgr90">[ade2ca70] </span><span class="sgr92">+ Dates v1.11.0</span>
  <span class="sgr90">[de0858da] </span><span class="sgr92">+ Printf v1.11.0</span>
  <span class="sgr90">[fa267f1f] </span><span class="sgr92">+ TOML v1.0.3</span>
  <span class="sgr90">[4ec0a83e] </span><span class="sgr92">+ Unicode v1.11.0</span>
<span class="sgr36"><span class="sgr1">        Info</span></span> Packages marked with <span class="sgr33">⌅</span> have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`
Precompiling project...
    296.5 ms  ✓ Blackjack
  1 dependency successfully precompiled in 2 seconds. 6 already precompiled.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.generate(&quot;BlackjackFacecards&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">  Generating</span></span>  project BlackjackFacecards:
    BlackjackFacecards/Project.toml
    BlackjackFacecards/src/BlackjackFacecards.jl</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.activate(&quot;BlackjackFacecards&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">  Activating</span></span> project at `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/BlackjackFacecards`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.develop(PackageSpec(path=joinpath(pwd(), &quot;Blackjack&quot;)));</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">   Resolving</span></span> package versions...
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/BlackjackFacecards/Project.toml`
  <span class="sgr90">[8b02e5e1] </span><span class="sgr92">+ Blackjack v0.1.0 `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/Blackjack`</span>
<span class="sgr32"><span class="sgr1">    Updating</span></span> `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/BlackjackFacecards/Manifest.toml`
  <span class="sgr90">[8b02e5e1] </span><span class="sgr92">+ Blackjack v0.1.0 `~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/Blackjack`</span>
<span class="sgr33">⌅</span> <span class="sgr90">[aea7be01] </span><span class="sgr92">+ PrecompileTools v1.2.1</span>
  <span class="sgr90">[21216c6a] </span><span class="sgr92">+ Preferences v1.4.3</span>
  <span class="sgr90">[ade2ca70] </span><span class="sgr92">+ Dates v1.11.0</span>
  <span class="sgr90">[de0858da] </span><span class="sgr92">+ Printf v1.11.0</span>
  <span class="sgr90">[fa267f1f] </span><span class="sgr92">+ TOML v1.0.3</span>
  <span class="sgr90">[4ec0a83e] </span><span class="sgr92">+ Unicode v1.11.0</span>
<span class="sgr36"><span class="sgr1">        Info</span></span> Packages marked with <span class="sgr33">⌅</span> have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`</code></pre><p>Now it&#39;s time to create the code for <code>Blackjack</code>. Normally, you&#39;d do this with an editor, but to make it reproducible here we&#39;ll use code to create these packages. The package code we&#39;ll create below defines the following:</p><ul><li>a <code>score</code> function to assign a numeric value to a card</li><li><code>tallyscore</code> which adds the total score for a hand of cards</li><li><code>playgame</code> which uses a simple strategy to decide whether to take another card from the deck and add it to the hand</li></ul><p>To reduce latency on first use, we then precompile <code>playgame</code>. In a real application, we&#39;d also want a function to manage the <code>deck</code> of cards, but for brevity we&#39;ll omit this and do it manually.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; write(joinpath(&quot;Blackjack&quot;, &quot;src&quot;, &quot;Blackjack.jl&quot;), &quot;&quot;&quot;
           module Blackjack
       
           using PrecompileTools
       
           export playgame
       
           const deck = []   # the deck of cards that can be dealt
       
           # Compute the score of one card
           score(card::Int) = card
       
           # Add up the score in a hand of cards
           function tallyscores(cards)
               s = 0
               for card in cards
                   s += score(card)
               end
               return s
           end
       
           # Play the game! We use a simple strategy to decide whether to draw another card.
           function playgame()
               myhand = []
               while tallyscores(myhand) &lt;= 14 &amp;&amp; !isempty(deck)
                   push!(myhand, pop!(deck))   # &quot;Hit me!&quot;
               end
               myscore = tallyscores(myhand)
               return myscore &lt;= 21 ? myscore : &quot;Busted&quot;
           end
       
           # Precompile `playgame`:
           @setup_workload begin
               push!(deck, 8, 10)    # initialize the deck
               @compile_workload begin
                   playgame()
               end
           end
       
           end
           &quot;&quot;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">793</code></pre><p>Suppose you use <code>Blackjack</code> and like it, but you notice it doesn&#39;t support face cards. Perhaps you&#39;re nervous about contributing to the <code>Blackjack</code> package (you shouldn&#39;t be!), and so you decide to start your own package that extends its functionality. You create <code>BlackjackFacecards</code> to add scoring of the jack, queen, king, and ace (for simplicity we&#39;ll make the ace always worth 11):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; write(joinpath(&quot;BlackjackFacecards&quot;, &quot;src&quot;, &quot;BlackjackFacecards.jl&quot;), &quot;&quot;&quot;
           module BlackjackFacecards
       
           using Blackjack
       
           # Add a new `score` method:
           Blackjack.score(card::Char) = card ∈ (&#39;J&#39;, &#39;Q&#39;, &#39;K&#39;) ? 10 :
                                         card == &#39;A&#39; ? 11 : error(card, &quot; not known&quot;)
       
           end
           &quot;&quot;&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">214</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Because <code>BlackjackFacecards</code> &quot;owns&quot; neither <code>Char</code> nor <code>score</code>, this is <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy-1">piracy</a> and should generally be avoided. Piracy is one way to cause invalidations, but it&#39;s not the only one. <code>BlackjackFacecards</code> could avoid committing piracy by defining a <code>struct Facecard ... end</code> and defining <code>score(card::Facecard)</code> instead of <code>score(card::Char)</code>. However, this would <em>not</em> fix the invalidations–all the factors described below are unchanged.</p></div></div><p>Now we&#39;re ready!</p><h3 id="Recording-invalidations"><a class="docs-heading-anchor" href="#Recording-invalidations">Recording invalidations</a><a id="Recording-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-invalidations" title="Permalink"></a></h3><p>Here are the steps executed by the code below</p><ul><li>load <code>SnoopCompileCore</code></li><li>load <code>Blackjack</code> and <code>BlackjackFacecards</code> while <em>recording invalidations</em> with the <code>@snoop_invalidations</code> macro.</li><li>load <code>SnoopCompile</code> and <code>AbstractTrees</code> for analysis</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SnoopCompileCore</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; invs = @snoop_invalidations using Blackjack, BlackjackFacecards;</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr92"><span class="sgr1">Precompiling</span></span> Blackjack...
    472.3 ms<span class="sgr32">  ✓ </span>Blackjack
  1 dependency successfully precompiled in 0 seconds. 6 already precompiled.
<span class="sgr92"><span class="sgr1">Precompiling</span></span> BlackjackFacecards...
    333.2 ms<span class="sgr32">  ✓ </span>BlackjackFacecards
  1 dependency successfully precompiled in 0 seconds. 7 already precompiled.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SnoopCompile, AbstractTrees</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you get errors like <code>Package SnoopCompileCore not found in current path</code>, a likely explanation is that you didn&#39;t add it to your default environment. In the example above, we&#39;re in the <code>BlackjackFacecards</code> environment so we can develop the package, but you also need access to <code>SnoopCompile</code> and <code>SnoopCompileCore</code>. Having these in your <a href="https://docs.julialang.org/en/v1/manual/code-loading/#Environment-stacks">default environment</a> lets them be found even if they aren&#39;t part of the current environment.</p></div></div><h3 id="Analyzing-invalidations"><a class="docs-heading-anchor" href="#Analyzing-invalidations">Analyzing invalidations</a><a id="Analyzing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-invalidations" title="Permalink"></a></h3><p>Now we&#39;re ready to see what, if anything, got invalidated:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; trees = invalidation_trees(invs)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SnoopCompile.MethodInvalidations}:
 inserting <span class="sgr95">score(</span><span class="sgr90">card</span>::<span class="sgr1">Char</span>)<span class="sgr90"> @</span> <span class="sgr90">BlackjackFacecards</span> <span class="sgr90">~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/BlackjackFacecards/src/<span class="sgr4">BlackjackFacecards.jl:6</span></span> invalidated:
   mt_backedges: 1: signature <span class="sgr96">Tuple{typeof(Blackjack.score), Any}</span> triggered <span class="sgr93">MethodInstance for Blackjack.tallyscores(::Vector{Any})</span> (1 children)</code></pre><p>This has only one &quot;tree&quot; of invalidations. <code>trees</code> is a <code>Vector</code> so we can index it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; tree = trees[1]</code><code class="nohighlight hljs ansi" style="display:block;">inserting <span class="sgr95">score(</span><span class="sgr90">card</span>::<span class="sgr1">Char</span>)<span class="sgr90"> @</span> <span class="sgr90">BlackjackFacecards</span> <span class="sgr90">~/work/SnoopCompile.jl/SnoopCompile.jl/docs/build/tutorials/BlackjackFacecards/src/<span class="sgr4">BlackjackFacecards.jl:6</span></span> invalidated:
   mt_backedges: 1: signature <span class="sgr96">Tuple{typeof(Blackjack.score), Any}</span> triggered <span class="sgr93">MethodInstance for Blackjack.tallyscores(::Vector{Any})</span> (1 children)</code></pre><p>Each tree stems from a single <em>cause</em> described in the top line. For this tree, the cause was adding the new method <code>score(::Char)</code> in <code>BlackjackFacecards</code>.</p><p>Each <em>cause</em> is associated with one or more <em>victims</em> of invalidation, a list here named <code>mt_backedges</code>. Let&#39;s extract the final (and in this case, only) victim:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sig, victim = tree.mt_backedges[end];</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>mt_backedges</code> stands for &quot;MethodTable backedges.&quot; In other cases you may see a second type of invalidation, just called <code>backedges</code>. With these, there is no <code>sig</code>, and so you&#39;ll use just <code>victim = tree.backedges[i]</code>.</p></div></div><p>First let&#39;s look at the the problematic method <code>sig</code>nature:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sig</code><code class="nohighlight hljs ansi" style="display:block;">Tuple{typeof(Blackjack.score), Any}</code></pre><p>This is a type-tuple, i.e., <code>Tuple{typeof(f), typesof(args)...}</code>. We see that <code>score</code> was called on an object of (inferred) type <code>Any</code>. <strong>Calling a function with unknown argument types makes code vulnerable to invalidation, and insertion of the new <code>score</code> method &quot;exploited&quot; this vulnerability.</strong></p><p><code>victim</code> shows which compiled code got invalidated:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; victim</code><code class="nohighlight hljs ansi" style="display:block;">MethodInstance for Blackjack.tallyscores(::Vector{Any}) at depth 0 with 1 children</code></pre><p>But this is not the full extent of what got invalidated:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(victim)</code><code class="nohighlight hljs ansi" style="display:block;">MethodInstance for Blackjack.tallyscores(::Vector{Any}) at depth 0 with 1 children
└─ MethodInstance for playgame() at depth 1 with 0 children</code></pre><p>Invalidations propagate throughout entire call trees, here up to <code>playgame()</code>: anything that calls code that may no longer be correct is itself at risk for being incorrect. In general, victims with lots of &quot;children&quot; deserve the greatest attention.</p><p>While <code>print_tree</code> can be useful, Cthulhu&#39;s <code>ascend</code> is a far more powerful tool for gaining deeper insight:</p><pre><code class="language-julia hljs">julia&gt; using Cthulhu

julia&gt; ascend(victim)
Choose a call for analysis (q to quit):
 &gt;   tallyscores(::Vector{Any})
       playgame()</code></pre><p>This is an interactive REPL-menu, described more completely (via text and video) at <a href="https://github.com/JuliaDebug/Cthulhu.jl?tab=readme-ov-file#usage-ascend">ascend</a>.</p><p>There are quite a few other tools for working with <code>invs</code> and <code>trees</code>, see the <a href="../../reference/#Reference">Reference</a>. If your list of invalidations is dauntingly large, you may be interested in <a href="../../reference/#SnoopCompile.precompile_blockers">precompile_blockers</a>.</p><h3 id="Why-the-invalidations-occur"><a class="docs-heading-anchor" href="#Why-the-invalidations-occur">Why the invalidations occur</a><a id="Why-the-invalidations-occur-1"></a><a class="docs-heading-anchor-permalink" href="#Why-the-invalidations-occur" title="Permalink"></a></h3><p><code>tallyscores</code> and <code>playgame</code> were compiled in <code>Blackjack</code>, a &quot;world&quot; where the <code>score</code> method defined in <code>BlackjackFacecards</code> does not yet exist. When you load the <code>BlackjackFacecards</code> package, Julia must ask itself: now that this new <code>score</code> method exists, am I certain that I would compile <code>tallyscores</code> the same way? If the answer is &quot;no,&quot; Julia invalidates the old compiled code, and compiles a fresh version with full awareness of the new <code>score</code> method in <code>BlackjackFacecards</code>.</p><p>Why would the compilation of <code>tallyscores</code> change? Evidently, <code>cards</code> is a <code>Vector{Any}</code>, and this means that <code>tallyscores</code> can&#39;t guess what kind of object <code>card</code> might be, and thus it can&#39;t guess what kind of objects are passed into <code>score</code>. The crux of the invalidation is thus:</p><ul><li>when <code>Blackjack</code> is compiled, inference does not know which <code>score</code> method will be called. However, at the time of compilation the only <code>score</code> method is for <code>Int</code>. Thus Julia will reason that anything that isn&#39;t an <code>Int</code> is going to trigger an error anyway, and so you might as well optimize <code>tallyscore</code> expecting all cards to be <code>Int</code>s.</li><li>however, when <code>BlackjackFacecards</code> is loaded, suddenly there are two <code>score</code> methods supporting both <code>Int</code> and <code>Char</code>. Now Julia&#39;s guess that all <code>cards</code> will probably be <code>Int</code>s doesn&#39;t seem so likely to be true, and thus <code>tallyscores</code> should be recompiled.</li></ul><p>Thus, invalidations arise from optimization based on what methods and types are &quot;in the world&quot; at the time of compilation (sometimes called <em>world-splitting</em>). This form of optimization can have performance benefits, but it also leaves your code vulnerable to invalidation.</p><h3 id="Fixing-invalidations"><a class="docs-heading-anchor" href="#Fixing-invalidations">Fixing invalidations</a><a id="Fixing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-invalidations" title="Permalink"></a></h3><p>In broad strokes, there are three ways to prevent invalidation.</p><h4 id="Method-1:-defer-compilation-until-the-full-world-is-known"><a class="docs-heading-anchor" href="#Method-1:-defer-compilation-until-the-full-world-is-known">Method 1: defer compilation until the full world is known</a><a id="Method-1:-defer-compilation-until-the-full-world-is-known-1"></a><a class="docs-heading-anchor-permalink" href="#Method-1:-defer-compilation-until-the-full-world-is-known" title="Permalink"></a></h4><p>The first and simplest technique is to ensure that the full range of possibilties (the entire &quot;world of code&quot;) is present before any compilation occurs. In this case, probably the best approach would be to merge the <code>BlackjackFacecards</code> package into <code>Blackjack</code> itself. Or, if you are a maintainer of the &quot;Blackjack ecosystem&quot; and have reasons for thinking that keeping the packages separate makes sense, you could alternatively move the <code>PrecompileTools</code> workload to <code>BlackjackFacecards</code>. Either approach should prevent the invalidations from occuring.</p><h4 id="Method-2:-improve-inferability"><a class="docs-heading-anchor" href="#Method-2:-improve-inferability">Method 2: improve inferability</a><a id="Method-2:-improve-inferability-1"></a><a class="docs-heading-anchor-permalink" href="#Method-2:-improve-inferability" title="Permalink"></a></h4><p>The second way to prevent invalidations is to improve the inferability of the victim(s). If <code>Int</code> and <code>Char</code> really are the only possible kinds of cards, then in <code>playgame</code> it would be better to declare</p><pre><code class="language-julia hljs">myhand = Union{Int,Char}[]</code></pre><p>and similarly for <code>deck</code> itself. That untyped <code>[]</code> is what makes <code>myhand</code> (and thus <code>cards</code>, when passed to <code>tallyscore</code>) a <code>Vector{Any}</code>, and the possibilities for <code>card</code> are endless. By constraining the possible types, we allow inference to know more clearly what methods might be called. More tips on fixing invalidations through improving inference can be found in <a href="../../explanations/fixing_inference/#Techniques-for-fixing-inference-problems">Techniques for fixing inference problems</a>.</p><p>In this particular case, just annotating <code>Union{Int,Char}[]</code> isn&#39;t sufficient on its own, because the <code>score</code> method for <code>Char</code> doesn&#39;t yet exist, so Julia doesn&#39;t know what to call. However, in most real-world cases this change alone would be sufficient: usually all the needed methods exist, it&#39;s just a question of reassuring Julia that no other options are even possible.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This fix leverages <a href="https://julialang.org/blog/2018/08/union-splitting/">union-splitting</a>, which is conceptually related to &quot;world-splitting.&quot; However, union-splitting is far more effective at fixing inference problems, as it guarantees that no other possibilities will <em>ever</em> exist, no matter how many other methods get defined.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Many vulnerabilities can be fixed by improving inference. In complex code, it&#39;s easy to unwittingly write things in ways that defeat Julia&#39;s type inference. Tools that help you discover inference problems, like SnoopCompile and <a href="../../explanations/tools/#JET">JET</a>, help you discover these unwitting &quot;mistakes.&quot;</p></div></div><p>While in real life it&#39;s usually a bad idea to &quot;blame the victim,&quot; it&#39;s typically the right attitude for fixing invalidations. Keep in mind, though, that the source of the problem may not be the immediate victim: in this case, it was a poor container choice in <code>playgame</code> that put <code>tallyscore</code> in the bad position of having to operate on a <code>Vector{Any}</code>.</p><p>Improving inferability is probably the most broadly-applicable technique, and when applicable it usually gives the best outcomes: not only is your code more resistant to invalidation, but it&#39;s likely faster and compiles to smaller binaries. However, of the three approaches it is also the one that requires the deepest understanding of Julia&#39;s type system, and thus may be difficult for some coders to use.</p><p>There are cases where there is no good way to make the code inferable, in which case other strategies are needed.</p><h4 id="Method-3:-disable-Julia&#39;s-speculative-optimization"><a class="docs-heading-anchor" href="#Method-3:-disable-Julia&#39;s-speculative-optimization">Method 3: disable Julia&#39;s speculative optimization</a><a id="Method-3:-disable-Julia&#39;s-speculative-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Method-3:-disable-Julia&#39;s-speculative-optimization" title="Permalink"></a></h4><p>The third option is to prevent Julia&#39;s speculative optimization: one could replace <code>score(card)</code> with <code>invokelatest(score, card)</code>:</p><pre><code class="language-julia hljs">function tallyscores(cards)
    s = 0
    for card in cards
        s += invokelatest(score, card)
    end
    return s
end</code></pre><p>This forces Julia to always look up the appropriate method of <code>score</code> while the code is running, and thus prevents the speculative optimizations that leave the code vulnerable to invalidation. However, the cost is that your code may run somewhat more slowly, particularly here where the call is inside a loop.</p><p>If you plan to define at least two <code>score</code> methods, another way to turn off this optimization would be to declare</p><pre><code class="language-julia hljs">Base.Experimental.@max_methods 1 function score end</code></pre><p>before defining any <code>score</code> methods. You can read the documentation on <code>@max_methods</code> to learn more about how it works.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Most of us learn best by doing. Try at least one of these methods of fixing the invalidation, and use SnoopCompile to verify that it works.</p></div></div><h3 id="Undoing-the-damage-from-invalidations"><a class="docs-heading-anchor" href="#Undoing-the-damage-from-invalidations">Undoing the damage from invalidations</a><a id="Undoing-the-damage-from-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Undoing-the-damage-from-invalidations" title="Permalink"></a></h3><p>If you can&#39;t prevent the invalidation, an alternative approach is to recompile the invalidated code. For example, one could repeat the precompile workload from <code>Blackjack</code> in <code>BlackjackFacecards</code>. While this will mean that the whole &quot;stack&quot; will be compiled twice and cached twice (which is wasteful), it should be effective in reducing latency for users.</p><p>PrecompileTools also has a <code>@recompile_invalidations</code>. This isn&#39;t generally recommended for use in package (you can end up with long compile times for things you don&#39;t need), but it can be useful in personal &quot;Startup packages&quot; where you want to reduce latency for a particular project you&#39;re working on. See the PrecompileTools documentation for details.</p><pre><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">  Activating</span></span> project at `~/work/SnoopCompile.jl/SnoopCompile.jl/docs`</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« SnoopCompile.jl</a><a class="docs-footer-nextpage" href="../snoop_inference/">Tutorial on <code>@snoop_inference</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Wednesday 26 March 2025 14:20">Wednesday 26 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
