<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Snooping on and fixing invalidations: @snoop_invalidations · SnoopCompile</title><meta name="title" content="Snooping on and fixing invalidations: @snoop_invalidations · SnoopCompile"/><meta property="og:title" content="Snooping on and fixing invalidations: @snoop_invalidations · SnoopCompile"/><meta property="twitter:title" content="Snooping on and fixing invalidations: @snoop_invalidations · SnoopCompile"/><meta name="description" content="Documentation for SnoopCompile."/><meta property="og:description" content="Documentation for SnoopCompile."/><meta property="twitter:description" content="Documentation for SnoopCompile."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SnoopCompile</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><span class="tocitem">Basic tutorials</span><ul><li><a class="tocitem" href="../tutorials/invalidations/">Tutorial on <code>@snoop_invalidations</code></a></li><li><a class="tocitem" href="../tutorials/snoop_inference/">Tutorial on <code>@snoop_inference</code></a></li><li><a class="tocitem" href="../tutorials/snoop_llvm/">Tutorial on <code>@snoop_llvm</code></a></li><li><a class="tocitem" href="../tutorials/pgdsgui/">Profile-guided despecialization</a></li><li><a class="tocitem" href="../tutorials/jet/">Tutorial on JET integration</a></li></ul></li><li><span class="tocitem">Advanced tutorials</span><ul><li><a class="tocitem" href="../tutorials/snoop_inference_analysis/">Using <code>@snoop_inference</code> results to improve inferrability</a></li><li><a class="tocitem" href="../tutorials/snoop_inference_parcel/">Using <code>@snoop_inference</code> to emit manual precompile directives</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../explanations/tools/">Package roles and alternatives</a></li><li><a class="tocitem" href="../explanations/gotchas/">Precompilation &quot;gotcha&quot;s</a></li><li><a class="tocitem" href="../explanations/fixing_inference/">Techniques for fixing inference problems</a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Snooping on and fixing invalidations: <code>@snoop_invalidations</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Snooping on and fixing invalidations: <code>@snoop_invalidations</code></a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/snoop_invalidations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="invalidations"><a class="docs-heading-anchor" href="#invalidations">Snooping on and fixing invalidations: <code>@snoop_invalidations</code></a><a id="invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#invalidations" title="Permalink"></a></h1><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p><code>@snoop_invalidations</code> is available on <code>Julia 1.6.0-DEV.154</code> or above, but the results can be relevant for all Julia versions.</p></div></div><p>Invalidations occur when there is a danger that new methods would supersede older methods in previously-compiled code. For safety, Julia&#39;s compiler <em>invalidates</em> that old code, marking it as unsuitable for use; the next time you call that method, it will have to be compiled again from scratch. (If no one ever needs that method again, there is no major loss.)</p><p>Some packages define new methods that force invalidation of previously-compiled code. If your package, or any of your dependencies, triggers many invalidations, it has several bad effects:</p><ul><li>any invalidated methods you need for the functionality in your package will have to be recompiled. This will lead to a direct (and occasionally large) slowdown for your package.</li><li>invalidations by your dependencies (packages you rely on) can block precompilation of methods in your package, preventing you from taking advantage of some of the other features of SnoopCompile.</li><li>even if you don&#39;t need the invalidated code for your package, any invalidations triggered by your package might harm packages that depend on yours.</li></ul><p>For these reasons, it&#39;s advisable to begin by analyzing invalidations. On recent Julia versions, most packages do not trigger a large number of invalidations; often, all that is needed is a quick glance at invalidations before moving on to the next step. Occasionally, checking for invalidations can save you a lot of confusion and frustration at later steps, so it is well worth taking a look.</p><p>Readers who want more background and context are encouraged to read <a href="https://julialang.org/blog/2020/08/invalidations/">this blog post</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Invalidatons occur only for compiled code; method definitions themselves cannot be invalidated. As a consequence, it&#39;s possible to have latent invalidation risk; this risk can become exposed if you use some intermediate functionality before loading your package, or if your dependencies someday add <code>precompile</code> directives. So even if you&#39;ve checked for invalidations previously, sometimes it&#39;s worth taking a fresh look.</p></div></div><h2 id="Recording-invalidations"><a class="docs-heading-anchor" href="#Recording-invalidations">Recording invalidations</a><a id="Recording-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-invalidations" title="Permalink"></a></h2><p>To record the invalidations caused by defining new methods, use <a href="../reference/#SnoopCompileCore.@snoop_invalidations"><code>@snoop_invalidations</code></a>. <code>@snoop_invalidations</code> is exported by <code>SnoopCompile</code>, but the recommended approach is to record invalidations using the minimalistic <code>SnoopCompileCore</code> package, and then load <code>SnoopCompile</code> to do the analysis. <em><strong>Remember</strong></em> to run julia with the <code>--startup-file=&quot;no&quot;</code> flag set, if you load packages such as <a href="https://github.com/timholy/Revise.jl"><code>Revise</code></a> in your startup file. Otherwise invalidations relating to those packages will also show up.</p><pre><code class="language-julia hljs">using SnoopCompileCore
invalidations = @snoop_invalidations begin
    # package loads and/or method definitions that might invalidate other code
end
using SnoopCompile   # now that we&#39;ve collected the data, load the complete package to analyze the results</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>SnoopCompileCore</code> was split out from <code>SnoopCompile</code> to reduce the risk of invalidations from loading <code>SnoopCompile</code> itself. Once a <code>MethodInstance</code> gets invalidated, it doesn&#39;t show up in future <code>@snoop_invalidations</code> results, so anything that gets invalidated in order to provide <code>@snoop_invalidations</code> would be omitted from the results. <code>SnoopCompileCore</code> is a very small package with no dependencies and which avoids extending any of Julia&#39;s own functions, so it cannot invalidate any other code.</p></div></div><h2 id="Analyzing-invalidations"><a class="docs-heading-anchor" href="#Analyzing-invalidations">Analyzing invalidations</a><a id="Analyzing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-invalidations" title="Permalink"></a></h2><h3 id="A-first-example"><a class="docs-heading-anchor" href="#A-first-example">A first example</a><a id="A-first-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-first-example" title="Permalink"></a></h3><p>We&#39;ll walk through this process with the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; f(::Real) = 1;

julia&gt; callf(container) = f(container[1]);

julia&gt; call2f(container) = callf(container);</code></pre><p>Because code doesn&#39;t get compiled until it gets run, and invalidations only affect compiled code, let&#39;s run this with three different container types:</p><pre><code class="language-julia-repl hljs">julia&gt; c64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];  # Vector{Float64}, Vector{Float32}, and Vector{AbstractFloat}, respectively

julia&gt; call2f(c64)
1

julia&gt; call2f(c32)
1

julia&gt; call2f(cabs)
1</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you&#39;re following along, be sure you actually execute these methods, or you won&#39;t obtain the results below.</p></div></div><p>Now we&#39;ll define a new <code>f</code> method, one specialized for <code>Float64</code>. So we can see the consequences for the compiled code, we&#39;ll make this definition while snooping on the compiler with <code>@snoop_invalidations</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using SnoopCompileCore

julia&gt; invalidations = @snoop_invalidations f(::Float64) = 2;</code></pre><p>As should be apparent, running <code>call2f</code> on <code>c64</code> should produce a different result than formerly, so Julia certainly needs to invalidate that code.  Let&#39;s see what that looks like. The simplest thing we can do is list or count invalidations:</p><pre><code class="language-julia-repl hljs">julia&gt; using SnoopCompile

julia&gt; length(uinvalidated(invalidations))  # collect the unique MethodInstances &amp; count them
6</code></pre><p>The length of this set is your simplest insight into the extent of invalidations triggered by this method definition.</p><p>If you want to fix invalidations, it&#39;s crucial to know <em>why</em> certain <code>MethodInstance</code>s were invalidated. For that, it&#39;s best to use a tree structure, in which children are invalidated because their parents get invalidated:</p><pre><code class="language-julia-repl hljs">julia&gt; trees = invalidation_trees(invalidations)
1-element Vector{SnoopCompile.MethodInvalidations}:
 inserting f(::Float64) @ Main none:1 invalidated:
   backedges: 1: superseding f(::Real) @ Main none:1 with MethodInstance for f(::Float64) (2 children)
              2: superseding f(::Real) @ Main none:1 with MethodInstance for f(::AbstractFloat) (2 children)
   1 mt_cache</code></pre><p>The output, <code>trees</code>, is a vector of <code>MethodInvalidations</code>, a data type defined in <code>SnoopCompile</code>; each of these is the set of invalidations triggered by a particular method definition. In this case, we only defined one method, so we can get at most one <code>MethodInvalidation</code>. <code>@snoop_invalidations using SomePkg</code> might result in a list of such objects, each connected to a particular method defined in a particular package (either <code>SomePkg</code> itself or one of its dependencies).</p><p>In this case, &quot;<code>inserting f(::Float64)</code>&quot; indicates that we added a method with signature <code>f(::Float64)</code>, and that this method triggered invalidations. (Invalidations can also be triggered by method deletion, although this should not happen in typical usage.) Next, notice the <code>backedges</code> line, and the fact that there are two items listed for it. This indicates that there were two proximal triggers for the invalidation, both of which superseded the method <code>f(::Real)</code>. One of these had been compiled specifically for <code>Float64</code>, due to our <code>call2f(c64)</code>. The other had been compiled specifically for <code>AbstractFloat</code>, due to our <code>call2f(cabs)</code>.</p><p>You can look at these invalidation trees in greater detail:</p><pre><code class="language-julia-repl hljs">julia&gt; method_invalidations = trees[1];    # invalidations stemming from a single method

julia&gt; root = method_invalidations.backedges[1]  # get the first triggered invalidation
MethodInstance for f(::Float64) at depth 0 with 2 children

julia&gt; show(root)
MethodInstance for f(::Float64) (2 children)
 MethodInstance for callf(::Vector{Float64}) (1 children)
 ⋮

julia&gt; show(root; minchildren=0)
MethodInstance for f(::Float64) (2 children)
 MethodInstance for callf(::Vector{Float64}) (1 children)
  MethodInstance for call2f(::Vector{Float64}) (0 children)</code></pre><p>The indentation here reveals that <code>call2f</code> called <code>callf</code> which called <code>f</code>, and shows the entire &quot;chain&quot; of invalidations triggered by this method definition. Examining <code>root2 = method_invalidations.backedges[2]</code> yields similar results, but for <code>Vector{AbstractFloat}</code>.</p><h3 id="mt_backedges-invalidations"><a class="docs-heading-anchor" href="#mt_backedges-invalidations"><code>mt_backedges</code> invalidations</a><a id="mt_backedges-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#mt_backedges-invalidations" title="Permalink"></a></h3><p><code>MethodInvalidations</code> can have a second field, <code>mt_backedges</code>. These are invalidations triggered via the <code>MethodTable</code> for a particular function. When extracting <code>mt_backedges</code>, in addition to a root <code>MethodInstance</code> these also indicate a particular signature that triggered the invalidation. We can illustrate this by returning to the <code>call2f</code> example above:</p><pre><code class="language-julia-repl hljs">julia&gt; call2f([&quot;hello&quot;])
ERROR: MethodError: no method matching f(::String)
[...]

julia&gt; invalidations = @snoop_invalidations f(::AbstractString) = 2;

julia&gt; trees = invalidation_trees(invalidations)
1-element Vector{SnoopCompile.MethodInvalidations}:
 inserting f(::AbstractString) @ Main none:1 invalidated:
   mt_backedges: 1: signature Tuple{typeof(f), String} triggered MethodInstance for callf(::Vector{String}) (1 children)


julia&gt; sig, root = trees[1].mt_backedges[end];

julia&gt; sig
Tuple{typeof(f), String}

julia&gt; root
MethodInstance for callf(::Vector{String}) at depth 0 with 1 children</code></pre><p>You can see that the invalidating signature, <code>f(::String)</code>, is more specific than the signature of the defined method, but that it is what was minimally needed by <code>callf(::Vector{String})</code>.</p><p><code>mt_backedges</code> invalidations often reflect &quot;unhandled&quot; conditions in methods that have already been compiled.</p><h3 id="A-more-complex-example"><a class="docs-heading-anchor" href="#A-more-complex-example">A more complex example</a><a id="A-more-complex-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-more-complex-example" title="Permalink"></a></h3><p>The structure of these trees can be considerably more complicated. For example, if <code>callf</code> also got called by some other method, and that method had also been executed (forcing it to be compiled), then <code>callf</code> would have multiple children. This is often seen with more complex, real-world tests. As a medium-complexity example, try the following:</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Any demonstration involving real-world packages might be altered from what is shown here by new releases of the relevant packages.</p></div></div><pre><code class="language-julia hljs">julia&gt; using Revise

julia&gt; using SnoopCompileCore

julia&gt; invalidations = @snoop_invalidations using FillArrays;

julia&gt; using SnoopCompile

julia&gt; trees = invalidation_trees(invalidations)
3-element Vector{SnoopCompile.MethodInvalidations}:
 inserting all(f::Function, x::FillArrays.AbstractFill) in FillArrays at /pathto/.julia/packages/FillArrays/NjFh2/src/FillArrays.jl:556 invalidated:
   backedges: 1: superseding all(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:880 with MethodInstance for all(::Base.var&quot;#388#389&quot;{_A} where _A, ::AbstractArray) (3 children)
              2: superseding all(f, itr) in Base at reduce.jl:918 with MethodInstance for all(::Base.var&quot;#388#389&quot;{_A} where _A, ::Any) (3 children)

 inserting any(f::Function, x::FillArrays.AbstractFill) in FillArrays at /pathto/.julia/packages/FillArrays/NjFh2/src/FillArrays.jl:555 invalidated:
   backedges: 1: superseding any(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:877 with MethodInstance for any(::typeof(ismissing), ::AbstractArray) (1 children)
              2: superseding any(f, itr) in Base at reduce.jl:871 with MethodInstance for any(::typeof(ismissing), ::Any) (1 children)
              3: superseding any(f, itr) in Base at reduce.jl:871 with MethodInstance for any(::LoweredCodeUtils.var&quot;#11#12&quot;{_A} where _A, ::Any) (2 children)
              4: superseding any(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:877 with MethodInstance for any(::LoweredCodeUtils.var&quot;#11#12&quot;{_A} where _A, ::AbstractArray) (4 children)

 inserting broadcasted(::Base.Broadcast.DefaultArrayStyle{N}, op, r::FillArrays.AbstractFill{T,N,Axes} where Axes) where {T, N} in FillArrays at /pathto/.julia/packages/FillArrays/NjFh2/src/fillbroadcast.jl:8 invalidated:
   backedges: 1: superseding broadcasted(::S, f, args...) where S&lt;:Base.Broadcast.BroadcastStyle in Base.Broadcast at broadcast.jl:1265 with MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(JuliaInterpreter._Typeof), ::Any) (1 children)
              2: superseding broadcasted(::S, f, args...) where S&lt;:Base.Broadcast.BroadcastStyle in Base.Broadcast at broadcast.jl:1265 with MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) (177 children)</code></pre><p>Your specific results may differ from this, depending on which version of Julia and of packages you are using. In this case, you can see that three methods (one for <code>all</code>, one for <code>any</code>, and one for <code>broadcasted</code>) triggered invalidations. Perusing this list, you can see that methods in <code>Base</code>, <code>LoweredCodeUtils</code>, and <code>JuliaInterpreter</code> (the latter two were loaded by <code>Revise</code>) got invalidated by methods defined in <code>FillArrays</code>.</p><p>The most consequential ones (the ones with the most children) are listed last, and should be where you direct your attention first. That last entry looks particularly problematic, so let&#39;s extract it:</p><pre><code class="language-julia hljs">julia&gt; methinvs = trees[end];

julia&gt; root = methinvs.backedges[end]
MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) at depth 0 with 177 children

julia&gt; show(root; maxdepth=10)
MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) (177 children)
 MethodInstance for broadcasted(::typeof(string), ::AbstractArray) (176 children)
  MethodInstance for #unpack#104(::Bool, ::typeof(Pkg.PlatformEngines.unpack), ::String, ::String) (175 children)
   MethodInstance for (::Pkg.PlatformEngines.var&quot;#unpack##kw&quot;)(::NamedTuple{(:verbose,),Tuple{Bool}}, ::typeof(Pkg.PlatformEngines.unpack), ::String, ::String) (174 children)
    MethodInstance for #download_verify_unpack#109(::Nothing, ::Bool, ::Bool, ::Bool, ::Bool, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (165 children)
     MethodInstance for (::Pkg.PlatformEngines.var&quot;#download_verify_unpack##kw&quot;)(::NamedTuple{(:ignore_existence, :verbose),Tuple{Bool,Bool}}, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (33 children)
      MethodInstance for (::Pkg.Artifacts.var&quot;#39#40&quot;{Bool,String,Nothing})(::String) (32 children)
       MethodInstance for create_artifact(::Pkg.Artifacts.var&quot;#39#40&quot;{Bool,String,Nothing}) (31 children)
        MethodInstance for #download_artifact#38(::Bool, ::Bool, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String, ::Nothing) (30 children)
         MethodInstance for (::Pkg.Artifacts.var&quot;#download_artifact##kw&quot;)(::NamedTuple{(:verbose, :quiet_download),Tuple{Bool,Bool}}, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String, ::Nothing) (23 children)
          MethodInstance for (::Pkg.Artifacts.var&quot;#download_artifact##kw&quot;)(::NamedTuple{(:verbose, :quiet_download),Tuple{Bool,Bool}}, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String) (22 children)
          ⋮
        ⋮
     MethodInstance for (::Pkg.PlatformEngines.var&quot;#download_verify_unpack##kw&quot;)(::NamedTuple{(:ignore_existence,),Tuple{Bool}}, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (130 children)
      MethodInstance for (::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec})(::String) (116 children)
       MethodInstance for #mktempdir#21(::String, ::typeof(mktempdir), ::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}, ::String) (115 children)
        MethodInstance for mktempdir(::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}, ::String) (114 children)
         MethodInstance for mktempdir(::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}) (113 children)
          MethodInstance for clone_or_cp_registries(::Pkg.Types.Context, ::Vector{Pkg.Types.RegistrySpec}, ::String) (112 children)
          ⋮
     ⋮
   ⋮</code></pre><p>Here you can see a much more complex branching structure. From this, you can see that methods in <code>Pkg</code> are the most significantly affected; you could expect that loading <code>FillArrays</code> might slow down your next <code>Pkg</code> operation (perhaps depending on which operation you choose) executed in this same session.</p><p>Again, if you&#39;re following along, it&#39;s possible that you&#39;ll see something quite different, if subsequent development has protected <code>Pkg</code> against this form of invalidation.</p><h2 id="Filtering-invalidations"><a class="docs-heading-anchor" href="#Filtering-invalidations">Filtering invalidations</a><a id="Filtering-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-invalidations" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The experimental tool <a href="../reference/#SnoopCompile.precompile_blockers"><code>SnoopCompile.precompile_blockers</code></a> may be able to help you identify just the invalidations you need to fix for your use-case.</p></div></div><p>Some method definitions trigger widespread invalidation. If you don&#39;t have time to fix all of them, you might want to focus on a specific set of invalidations. For instance, you might be the author of <code>PkgA</code> and you&#39;ve noted that loading <code>PkgB</code> invalidates a lot of <code>PkgA</code>&#39;s code. In that case, you might want to find just those invalidations triggered in your package. You can find them with <a href="../reference/#SnoopCompile.filtermod"><code>filtermod</code></a>:</p><pre><code class="language-julia hljs">trees = invalidation_trees(@snoop_invalidations using PkgB)
ftrees = filtermod(PkgA, trees)</code></pre><p>By default, <code>filtermod</code> only selects trees where the root method was defined in the specified module. <code>filtermod(PkgA, trees; recursive=true)</code> will return all trees that lead to any method defined in <code>PkgA</code>.</p><p>A more selective yet exhaustive tool is <a href="../reference/#SnoopCompile.findcaller"><code>findcaller</code></a>, which allows you to find the path through the trees to a particular method:</p><pre><code class="language-julia hljs">m = @which f(data)                  # look for the &quot;path&quot; that invalidates this method
f(data)                             # run once to force compilation
using SnoopCompile
trees = invalidation_trees(@snoop_invalidations using SomePkg)
invs = findcaller(m, trees)         # select the branch that invalidated a compiled instance of `m`</code></pre><p>When you don&#39;t know which method to choose, but know an operation that got slowed down by loading <code>SomePkg</code>, you can use <code>@snoopi</code> to find methods that needed to be recompiled. See <a href="../reference/#SnoopCompile.findcaller"><code>findcaller</code></a> for further details.</p><h2 id="Fixing-invalidations"><a class="docs-heading-anchor" href="#Fixing-invalidations">Fixing invalidations</a><a id="Fixing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-invalidations" title="Permalink"></a></h2><p>In addition to the text below, there is a <a href="https://www.youtube.com/watch?v=7VbXbI6OmYo">video</a> illustrating many of the same package features. The video also walks through a real-world example fixing invalidations that stemmed from inference problems in some of <code>Pkg</code>&#39;s code.</p><h3 id="ascend"><a class="docs-heading-anchor" href="#ascend"><code>ascend</code></a><a id="ascend-1"></a><a class="docs-heading-anchor-permalink" href="#ascend" title="Permalink"></a></h3><p>SnoopCompile, partnering with the remarkable <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>, provides a tool called <code>ascend</code> to simplify diagnosing and fixing invalidations. To demonstrate this tool, let&#39;s use it on our test methods defined above. For best results, you&#39;ll want to copy those method definitions into a file:</p><pre><code class="language-julia hljs">f(::Real) = 1
callf(container) = f(container[1])
call2f(container) = callf(container)

c64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];
call2f(c64)
call2f(c32)
call2f(cabs)

using SnoopCompileCore
invalidations = @snoop_invalidations f(::Float64) = 2
using SnoopCompile
trees = invalidation_trees(invalidations)
method_invalidations = trees[1]</code></pre><p>and <code>include</code> it into a fresh session.  (The full functionality of <code>ascend</code> doesn&#39;t work for methods defined at the REPL, but does if the methods are defined in a file.) In this demo, I called that file <code>/tmp/snoop_invalidations.jl</code>.</p><p>We start with</p><pre><code class="language-julia hljs">julia&gt; root = method_invalidations.backedges[end]
MethodInstance for f(::AbstractFloat) at depth 0 with 2 children</code></pre><p>(It&#39;s common to start from the last element of <code>backedges</code> or <code>mt_backedges</code> since these have the largest number of children and are therefore most consequential.) Then:</p><pre><code class="language-julia hljs">julia&gt; ascend(root)
Choose a call for analysis (q to quit):
 &gt;   f(::AbstractFloat)
       callf(::Vector{AbstractFloat})
         call2f(::Vector{AbstractFloat})</code></pre><p>This is an interactive menu: press the down arrow to go down, the up arrow to go up, and <code>Enter</code> to select an item for more detailed analysis. In large trees, you may also want to &quot;fold&quot; nodes of the tree (collapsing it so that the children are no longer displayed), particularly if you are working your way through a long series of invalidations and want to hide ones you&#39;ve already dealt with. You toggle folding using the space bar, and folded nodes are printed with a <code>+</code> in front of them.</p><p>For example, if we press the down arrow once, we get</p><pre><code class="language-julia hljs">julia&gt; ascend(root)
Choose a call for analysis (q to quit):
     f(::AbstractFloat)
 &gt;     callf(::Vector{AbstractFloat})
         call2f(::Vector{AbstractFloat})</code></pre><p>Now hit <code>Enter</code> to select it:</p><pre><code class="language-julia hljs">Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:
 &gt; &quot;/tmp/snoop_invalidations.jl&quot;, callf: lines [2]
   Browse typed code</code></pre><p>This is showing you another menu, with only two options (a third is to go back by hitting <code>q</code>). The first entry shows you the option to open the &quot;offending&quot; source file in <code>callf</code> at the position of the call to the parent node of <code>callf</code>, which in this case is <code>f</code>. (Sometimes there will be more than one call to the parent within the method, in which case instead of showing <code>[1]</code> it might show <code>[1, 17, 39]</code> indicating each separate location.) Selecting this option, when available, is typically the best way to start because you can sometimes resolve the problem just by inspection of the source.</p><p>If you hit the down arrow</p><pre><code class="language-julia hljs">Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:
   &quot;/tmp/snoop_invalidations.jl&quot;, callf: lines [2]
 &gt; Browse typed code</code></pre><p>and then hit <code>Enter</code>, this is what you see:</p><pre><code class="language-julia hljs">│ ─ %-1  = invoke callf(::Vector{AbstractFloat})::Int64
Variables
  #self#::Core.Const(callf, false)
  container::Vector{AbstractFloat}

Body::Int64
    @ /tmp/snoop_invalidations.jl:2 within `callf&#39;
1 ─ %1 = Base.getindex(container, 1)::AbstractFloat
│   %2 = Main.f(%1)::Int64
└──      return %2

Select a call to descend into or ↩ to ascend. [q]uit. [b]ookmark.
Toggles: [o]ptimize, [w]arn, [d]ebuginfo, [s]yntax highlight for Source/LLVM/Native.
Show: [S]ource code, [A]ST, [L]LVM IR, [N]ative code
Advanced: dump [P]arams cache.

 • %1  = invoke getindex(::Vector{AbstractFloat},::Int64)::AbstractFloat
   %2  = call #f(::AbstractFloat)::Int64
   ↩</code></pre><p>This is output from Cthulhu, and you should see its documentation for more information. (See also <a href="https://www.youtube.com/watch?v=qf9oA09wxXY">this video</a>.) While it takes a bit of time to master Cthulhu, it is an exceptionally powerful tool for diagnosing and fixing inference issues.</p><h3 id="&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis"><a class="docs-heading-anchor" href="#&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis">&quot;Dead ends&quot;: finding runtime callers with MethodAnalysis</a><a id="&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis" title="Permalink"></a></h3><p>When a call is made by runtime dispatch and the world of available methods to handle the call does not narrow the types beyond what is known to the caller, the call-chain terminates. Here is a real-world example (one that may already be &quot;fixed&quot; by the time you read this) from analyzing invalidations triggered by specializing <code>Base.unsafe_convert(::Type{Ptr{T}}, ::Base.RefValue{S})</code> for specific types <code>S</code> and <code>T</code>:</p><pre><code class="nohighlight hljs">julia&gt; ascend(root)
Choose a call for analysis (q to quit):
 &gt;   unsafe_convert(::Type{Ptr{Nothing}}, ::Base.RefValue{_A} where _A)
       _show_default(::IOBuffer, ::Any)
         show_default(::IOBuffer, ::Function)
           show_function(::IOBuffer, ::Function, ::Bool)
             print(::IOBuffer, ::Function)
         show_default(::IOBuffer, ::ProcessFailedException)
           show(::IOBuffer, ::ProcessFailedException)
             print(::IOBuffer, ::ProcessFailedException)
         show_default(::IOBuffer, ::Sockets.IPAddr)
           show(::IOBuffer, ::Sockets.IPAddr)</code></pre><p>Unfortunately for our investigations, none of these &quot;top level&quot; callers have defined backedges. (Overall, it&#39;s very fortunate that they don&#39;t, in that runtime dispatch without backedges avoids any need to invalidate the caller; the alternative would be extremely long chains of completely unnecessary invalidation, which would have many undesirable consequences.)</p><p>If you want to fix such &quot;short chains&quot; of invalidation, one strategy is to identify callers by brute force search enabled by the <a href="https://github.com/timholy/MethodAnalysis.jl">MethodAnalysis.jl</a> package. For example, one can discover the caller of <code>show(::IOBuffer, ::Sockets.IPAddr)</code> with</p><pre><code class="language-julia hljs">using MethodAnalysis       # best from a fresh Julia session
mis = methodinstances();   # collect all *existing* MethodInstances (any future compilation will be ignored)
# Create a predicate that finds these argument types
using Sockets
argmatch(typs) = length(typs) &gt;= 2 &amp;&amp; typs[1] === IOBuffer &amp;&amp; typs[2] === Sockets.IPAddr
# Find any callers
callers = findcallers(show, argmatch, mis)</code></pre><p>which yields a single hit in <code>print(::IOBuffer, ::IPAddr)</code>. This too lacks any backedges, so a second application <code>findcallers(print, argmatch, mis)</code> links to <code>print_to_string(::IPAddr)</code>. This MethodInstance has a backedge to <code>string(::IPAddr)</code>, which has backedges to the method <code>Distributed.connect_to_worker(host::AbstractString, port::Integer)</code>. A bit of digging shows that this calls <code>Sockets.getaddrinfo</code> to look up an IP address, and this is inferred to return an <code>IPAddr</code> but the concrete type is unknown. A potential fix for this situation is described below.</p><p>This does not always work; for example, trying something similar for <code>ProcessExitedException</code> fails, likely because the call was made with even less type information. We might be able to find it with a more general predicate, for example</p><pre><code class="nohighlight hljs">argmatch(typs) = length(typs) &gt;= 2 &amp;&amp; typs[1] === IOBuffer &amp;&amp; ProcessExitedException &lt;: typs[2]</code></pre><p>but this returns a lot of candidates and it is difficult to guess which of these might be the culprit(s). Finally, <code>findcallers</code> only detects method calls that are &quot;hard-wired&quot; into type-inferred code; if the call we&#39;re seeking was made from toplevel, or if the function itself was a runtime variable, there is no hope that <code>findcallers</code> will detect it.</p><h3 id="Tips-for-fixing-invalidations"><a class="docs-heading-anchor" href="#Tips-for-fixing-invalidations">Tips for fixing invalidations</a><a id="Tips-for-fixing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-for-fixing-invalidations" title="Permalink"></a></h3><p>Invalidations occur in situations like our <code>call2f(c64)</code> example, where we changed our mind about what value <code>f</code> should return for <code>Float64</code>. Julia could not have returned the newly-correct answer without recompiling the call chain.</p><p>Aside from cases like these, most invalidations occur whenever new types are introduced, and some methods were previously compiled for abstract types. In some cases, this is inevitable, and the resulting invalidations simply need to be accepted as a consequence of a dynamic, updatable language. (As recommended above, you can often minimize invalidations by loading all your code at the beginning of your session, before triggering the compilation of more methods.) However, in many circumstances an invalidation indicates an opportunity to improve code. In our first example, note that the call <code>call2f(c32)</code> did not get invalidated: this is because the compiler knew all the specific types, and new methods did not affect any of those types. The main tips for writing invalidation-resistant code are:</p><ul><li>use <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-abstract-container-1">concrete types</a> wherever possible</li><li>write inferrable code</li><li>don&#39;t engage in <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy-1">type-piracy</a> (our <code>c64</code> example is essentially like type-piracy, where we redefined behavior for a pre-existing type)</li></ul><p>Since these tips also improve performance and allow programs to behave more predictably, these guidelines are not intrusive. Indeed, searching for and eliminating invalidations can help you improve the quality of your code.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 23 July 2024 16:12">Tuesday 23 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
