<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using @snoop_inference to emit manual precompile directives · SnoopCompile</title><meta name="title" content="Using @snoop_inference to emit manual precompile directives · SnoopCompile"/><meta property="og:title" content="Using @snoop_inference to emit manual precompile directives · SnoopCompile"/><meta property="twitter:title" content="Using @snoop_inference to emit manual precompile directives · SnoopCompile"/><meta name="description" content="Documentation for SnoopCompile."/><meta property="og:description" content="Documentation for SnoopCompile."/><meta property="twitter:description" content="Documentation for SnoopCompile."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SnoopCompile</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SnoopCompile.jl</a></li><li><span class="tocitem">Basic tutorials</span><ul><li><a class="tocitem" href="../invalidations/">Tutorial on <code>@snoop_invalidations</code></a></li><li><a class="tocitem" href="../snoop_inference/">Tutorial on <code>@snoop_inference</code></a></li><li><a class="tocitem" href="../snoop_llvm/">Tutorial on <code>@snoop_llvm</code></a></li><li><a class="tocitem" href="../pgdsgui/">Profile-guided despecialization</a></li><li><a class="tocitem" href="../jet/">Tutorial on JET integration</a></li></ul></li><li><span class="tocitem">Advanced tutorials</span><ul><li><a class="tocitem" href="../snoop_inference_analysis/">Using <code>@snoop_inference</code> results to improve inferrability</a></li><li class="is-active"><a class="tocitem" href>Using <code>@snoop_inference</code> to emit manual precompile directives</a><ul class="internal"><li><a class="tocitem" href="#SnoopCompile.write"><span>SnoopCompile.write</span></a></li><li><a class="tocitem" href="#Final-results"><span>Final results</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../explanations/tools/">Package roles and alternatives</a></li><li><a class="tocitem" href="../../explanations/gotchas/">Precompilation &quot;gotcha&quot;s</a></li><li><a class="tocitem" href="../../explanations/fixing_inference/">Techniques for fixing inference problems</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced tutorials</a></li><li class="is-active"><a href>Using <code>@snoop_inference</code> to emit manual precompile directives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using <code>@snoop_inference</code> to emit manual precompile directives</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/tutorials/snoop_inference_parcel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="precompilation"><a class="docs-heading-anchor" href="#precompilation">Using <code>@snoop_inference</code> to emit manual precompile directives</a><a id="precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#precompilation" title="Permalink"></a></h1><p>In a few cases, it may be inconvenient or impossible to precompile using a <a href="https://julialang.github.io/PrecompileTools.jl/stable/#Tutorial:-forcing-precompilation-with-workloads">workload</a>. Some examples might be:</p><ul><li>an application that opens graphical windows</li><li>an application that connects to a database</li><li>an application that creates, deletes, or rewrites files on disk</li></ul><p>In such cases, one alternative is to create a manual list of precompile directives using Julia&#39;s <code>precompile(f, argtypes)</code> function.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Manual precompile directives are much more likely to &quot;go stale&quot; as the package is developed–-<code>precompile</code> does not throw an error if a method for the given <code>argtypes</code> cannot be found. They are also more likely to be dependent on the Julia version, operating system, or CPU architecture. Whenever possible, it&#39;s safer to use a workload.</p></div></div><p><code>precompile</code> directives have to be emitted by the module that owns the method and/or types. SnoopCompile comes with a tool, <code>parcel</code>, that splits out the &quot;root-most&quot; precompilable MethodInstances into their constituent modules. This will typically correspond to the bottom row of boxes in the <a href="../snoop_inference/#flamegraph">flame graph</a>. In cases where you have some non-precompilable MethodInstances, they will include MethodInstances from higher up in the call tree.</p><p>Let&#39;s use <code>SnoopCompile.parcel</code> on <a href="../snoop_inference_analysis/#inferrability"><code>OptimizeMeFixed</code></a>:</p><pre><code class="language-julia hljs">julia&gt; ttot, pcs = SnoopCompile.parcel(tinf);

julia&gt; ttot
0.6084431670000001

julia&gt; pcs
4-element Vector{Pair{Module, Tuple{Float64, Vector{Tuple{Float64, Core.MethodInstance}}}}}:
                 Core =&gt; (0.000135179, [(0.000135179, MethodInstance for (NamedTuple{(:sizehint,), T} where T&lt;:Tuple)(::Tuple{Int64}))])
                 Base =&gt; (0.028383533000000002, [(3.2456e-5, MethodInstance for getproperty(::IOBuffer, ::Symbol)), (4.7474e-5, MethodInstance for ==(::Type, ::Nothing)), (5.7944e-5, MethodInstance for typeinfo_eltype(::Type)), (0.00039092299999999994, MethodInstance for show(::IOContext{IOBuffer}, ::Any)), (0.000433143, MethodInstance for IOContext(::IOBuffer, ::IOContext{Base.TTY})), (0.000484984, MethodInstance for Pair{Symbol, DataType}(::Any, ::Any)), (0.000742383, MethodInstance for print(::IOContext{Base.TTY}, ::String, ::String, ::Vararg{String, N} where N)), (0.001293705, MethodInstance for Pair(::Symbol, ::Type)), (0.0018914350000000003, MethodInstance for show(::IOContext{IOBuffer}, ::UInt16)), (0.010604793000000001, MethodInstance for show(::IOContext{IOBuffer}, ::Tuple{String, Int64})), (0.012404293, MethodInstance for show(::IOContext{IOBuffer}, ::Vector{Int64}))])
             Base.Ryu =&gt; (0.15733664599999997, [(0.05721630600000001, MethodInstance for writeshortest(::Vector{UInt8}, ::Int64, ::Float32, ::Bool, ::Bool, ::Bool, ::Int64, ::UInt8, ::Bool, ::UInt8, ::Bool, ::Bool)), (0.10012033999999997, MethodInstance for show(::IOContext{IOBuffer}, ::Float32))])
 Main.OptimizeMeFixed =&gt; (0.4204474180000001, [(0.4204474180000001, MethodInstance for main())])</code></pre><p>This tells us that a total of ~0.6s were spent on inference. <code>parcel</code> discovered precompilable MethodInstances for four modules, <code>Core</code>, <code>Base</code>, <code>Base.Ryu</code>, and <code>OptimizeMeFixed</code>. These are listed in increasing order of inference time.</p><p>Let&#39;s look specifically at <code>OptimizeMeFixed</code>, since that&#39;s under our control:</p><pre><code class="language-julia hljs">julia&gt; pcmod = pcs[end]
Main.OptimizeMeFixed =&gt; (0.4204474180000001, Tuple{Float64, Core.MethodInstance}[(0.4204474180000001, MethodInstance for main())])

julia&gt; tmod, tpcs = pcmod.second;

julia&gt; tmod
0.4204474180000001

julia&gt; tpcs
1-element Vector{Tuple{Float64, Core.MethodInstance}}:
 (0.4204474180000001, MethodInstance for main())</code></pre><p>0.42s of that time is due to <code>OptimizeMeFixed</code>, and <code>parcel</code> discovered a single MethodInstances to precompile, <code>main()</code>.</p><p>We could look at the other modules (packages) similarly.</p><h2 id="SnoopCompile.write"><a class="docs-heading-anchor" href="#SnoopCompile.write">SnoopCompile.write</a><a id="SnoopCompile.write-1"></a><a class="docs-heading-anchor-permalink" href="#SnoopCompile.write" title="Permalink"></a></h2><p>You can generate files that contain ready-to-use <code>precompile</code> directives using <code>SnoopCompile.write</code>:</p><pre><code class="language-julia hljs">julia&gt; SnoopCompile.write(&quot;/tmp/precompiles_OptimizeMe&quot;, pcs)
Core: no precompile statements out of 0.000135179
Base: precompiled 0.026194226 out of 0.028383533000000002
Base.Ryu: precompiled 0.15733664599999997 out of 0.15733664599999997
Main.OptimizeMeFixed: precompiled 0.4204474180000001 out of 0.4204474180000001</code></pre><p>You&#39;ll now find a directory <code>/tmp/precompiles_OptimizeMe</code>, and inside you&#39;ll find three files, for <code>Base</code>, <code>Base.Ryu</code>, and <code>OptimizeMeFixed</code>, respectively. The contents of the last of these should be recognizable:</p><pre><code class="language-julia hljs">function _precompile_()
    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing
    Base.precompile(Tuple{typeof(main)})   # time: 0.4204474
end</code></pre><p>The first <code>ccall</code> line ensures we only pay the cost of running these <code>precompile</code> directives if we&#39;re building the package; this is relevant mostly if you&#39;re running Julia with <code>--compiled-modules=no</code>, which can be a convenient way to disable precompilation and examine packages in their &quot;native state.&quot; (It would also matter if you&#39;ve set <code>__precompile__(false)</code> at the top of your module, but if so why are you reading this?)</p><p>This file is ready to be moved into the <code>OptimizeMe</code> repository and <code>include</code>d into your module definition. Since we added <code>warmup</code> manually, you could consider moving <code>precompile(warmup, ())</code> into this function.</p><p>You might also consider submitting some of the other files (or their <code>precompile</code> directives) to the packages you depend on. In some cases, the specific argument type combinations may be too &quot;niche&quot; to be worth specializing; one such case is found here, a <code>show</code> method for <code>Tuple{String, Int64}</code> for <code>Base</code>. But in other cases, these may be very worthy additions to the package.</p><h2 id="Final-results"><a class="docs-heading-anchor" href="#Final-results">Final results</a><a id="Final-results-1"></a><a class="docs-heading-anchor-permalink" href="#Final-results" title="Permalink"></a></h2><p>Let&#39;s check out the final results of adding these <code>precompile</code> directives to <code>OptimizeMeFixed</code>. First, let&#39;s build both modules as precompiled packages:</p><pre><code class="language-julia hljs">ulia&gt; push!(LOAD_PATH, &quot;.&quot;)
4-element Vector{String}:
 &quot;@&quot;
 &quot;@v#.#&quot;
 &quot;@stdlib&quot;
 &quot;.&quot;

julia&gt; using OptimizeMe
[ Info: Precompiling OptimizeMe [top-level]

julia&gt; using OptimizeMeFixed
[ Info: Precompiling OptimizeMeFixed [top-level]</code></pre><p>Now in fresh sessions,</p><pre><code class="language-julia hljs">julia&gt; @time (using OptimizeMe; OptimizeMe.main())
3.14 is great
2.718 is jealous
⋮
Object x: 7
  3.159908 seconds (10.63 M allocations: 582.091 MiB, 5.19% gc time, 99.67% compilation time)</code></pre><p>versus</p><pre><code class="language-julia hljs">julia&gt; @time (using OptimizeMeFixed; OptimizeMeFixed.main())
3.14 is great
2.718 is jealous
⋮
 Object x: 7
  1.840034 seconds (5.38 M allocations: 289.402 MiB, 5.03% gc time, 96.70% compilation time)</code></pre><p>We&#39;ve cut down on the latency by nearly a factor of two. Moreover, if Julia someday caches generated code, we&#39;re well-prepared to capitalize on the benefits, because the same improvements in &quot;code ownership&quot; are almost certain to pay dividends there too.</p><p>If you inspect the results, you may sometimes suffer a few disappointments: some methods that we expected to precompile don&#39;t &quot;take.&quot; At the moment there appears to be a small subset of methods that fail to precompile, and the reasons are not yet widely understood. At present, the best advice seems to be to comment-out any precompile directives that don&#39;t &quot;take,&quot; since otherwise they increase the build time for the package without material benefit. These failures may be addressed in future versions of Julia. It&#39;s also worth appreciating how much we have succeeded in reducing latency, with the awareness that we may be able to get even greater benefit in the future.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p><code>@snoop_inference</code> collects enough data to learn which methods are triggering inference, how heavily methods are being specialized, and so on. Examining your code from the standpoint of inference and specialization may be unfamiliar at first, but like other aspects of package development (testing, documentation, and release compatibility management) it can lead to significant improvements in the quality-of-life for you and your users.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../snoop_inference_analysis/">« Using <code>@snoop_inference</code> results to improve inferrability</a><a class="docs-footer-nextpage" href="../../explanations/tools/">Package roles and alternatives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 23 July 2024 15:30">Tuesday 23 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
