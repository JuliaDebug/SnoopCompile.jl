<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Techniques for fixing inference problems · SnoopCompile</title><meta name="title" content="Techniques for fixing inference problems · SnoopCompile"/><meta property="og:title" content="Techniques for fixing inference problems · SnoopCompile"/><meta property="twitter:title" content="Techniques for fixing inference problems · SnoopCompile"/><meta name="description" content="Documentation for SnoopCompile."/><meta property="og:description" content="Documentation for SnoopCompile."/><meta property="twitter:description" content="Documentation for SnoopCompile."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SnoopCompile</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SnoopCompile.jl</a></li><li><span class="tocitem">Basic tutorials</span><ul><li><a class="tocitem" href="../../tutorials/invalidations/">Tutorial on <code>@snoop_invalidations</code></a></li><li><a class="tocitem" href="../../tutorials/snoop_inference/">Tutorial on <code>@snoop_inference</code></a></li><li><a class="tocitem" href="../../tutorials/snoop_llvm/">Tutorial on <code>@snoop_llvm</code></a></li><li><a class="tocitem" href="../../tutorials/pgdsgui/">Profile-guided despecialization</a></li><li><a class="tocitem" href="../../tutorials/jet/">Tutorial on JET integration</a></li></ul></li><li><span class="tocitem">Advanced tutorials</span><ul><li><a class="tocitem" href="../../tutorials/snoop_inference_analysis/">Using <code>@snoop_inference</code> results to improve inferrability</a></li><li><a class="tocitem" href="../../tutorials/snoop_inference_parcel/">Using <code>@snoop_inference</code> to emit manual precompile directives</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../tools/">Package roles and alternatives</a></li><li><a class="tocitem" href="../gotchas/">Precompilation &quot;gotcha&quot;s</a></li><li class="is-active"><a class="tocitem" href>Techniques for fixing inference problems</a><ul class="internal"><li><a class="tocitem" href="#Adding-type-annotations"><span>Adding type annotations</span></a></li><li><a class="tocitem" href="#Inferrable-field-access-for-abstract-types"><span>Inferrable field access for abstract types</span></a></li><li><a class="tocitem" href="#Fixing-Core.Box"><span>Fixing <code>Core.Box</code></span></a></li><li><a class="tocitem" href="#Handling-edge-cases"><span>Handling edge cases</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Explanations</a></li><li class="is-active"><a href>Techniques for fixing inference problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Techniques for fixing inference problems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/explanations/fixing_inference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Techniques-for-fixing-inference-problems"><a class="docs-heading-anchor" href="#Techniques-for-fixing-inference-problems">Techniques for fixing inference problems</a><a id="Techniques-for-fixing-inference-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Techniques-for-fixing-inference-problems" title="Permalink"></a></h1><p>Here we assume you&#39;ve dug into your code with a tool like Cthulhu, and want to know how to fix some of the problems that you discover. Below is a collection of specific cases and some tricks for handling them.</p><p>Note that there is also a <a href="../../tutorials/snoop_inference_analysis/#inferrability">tutorial on fixing inference</a> that delves into advanced topics.</p><h2 id="Adding-type-annotations"><a class="docs-heading-anchor" href="#Adding-type-annotations">Adding type annotations</a><a id="Adding-type-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-type-annotations" title="Permalink"></a></h2><h3 id="Using-concrete-types"><a class="docs-heading-anchor" href="#Using-concrete-types">Using concrete types</a><a id="Using-concrete-types-1"></a><a class="docs-heading-anchor-permalink" href="#Using-concrete-types" title="Permalink"></a></h3><p>Defining variables like <code>list = []</code> can be convenient, but it creates a <code>list</code> of type <code>Vector{Any}</code>. This prevents inference from knowing the type of items extracted from <code>list</code>. Using <code>list = String[]</code> for a container of strings, etc., is an excellent fix. When in doubt, check the type with <code>isconcretetype</code>: a common mistake is to think that <code>list_of_lists = Array{Int}[]</code> gives you a vector-of-vectors, but</p><pre><code class="language-julia-repl hljs">julia&gt; isconcretetype(Array{Int})
false</code></pre><p>reminds you that <code>Array</code> requires a second parameter indicating the dimensionality of the array. (Or use <code>list_of_lists = Vector{Int}[]</code> instead, as <code>Vector{Int} === Array{Int, 1}</code>.)</p><p>Many valuable tips can be found among <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">Julia&#39;s performance tips</a>, and readers are encouraged to consult that page.</p><h3 id="Working-with-non-concrete-types"><a class="docs-heading-anchor" href="#Working-with-non-concrete-types">Working with non-concrete types</a><a id="Working-with-non-concrete-types-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-non-concrete-types" title="Permalink"></a></h3><p>In cases where invalidations occur, but you can&#39;t use concrete types (there are indeed many valid uses of <code>Vector{Any}</code>), you can often prevent the invalidation using some additional knowledge. One common example is extracting information from an <a href="https://docs.julialang.org/en/v1/manual/networking-and-streams/#IO-Output-Contextual-Properties-1"><code>IOContext</code></a> structure, which is roughly defined as</p><pre><code class="language-julia hljs">struct IOContext{IO_t &lt;: IO} &lt;: AbstractPipe
    io::IO_t
    dict::ImmutableDict{Symbol, Any}
end</code></pre><p>There are good reasons that <code>dict</code> uses a value-type of <code>Any</code>, but that makes it impossible for the compiler to infer the type of any object looked up in an <code>IOContext</code>. Fortunately, you can help! For example, the documentation specifies that the <code>:color</code> setting should be a <code>Bool</code>, and since it appears in documentation it&#39;s something we can safely enforce. Changing</p><pre><code class="nohighlight hljs">iscolor = get(io, :color, false)</code></pre><p>to</p><pre><code class="nohighlight hljs">iscolor = get(io, :color, false)::Bool     # assert that the rhs is Bool-valued</code></pre><p>will throw an error if it isn&#39;t a <code>Bool</code>, and this allows the compiler to take advantage of the type being known in subsequent operations.</p><p>If the return type is one of a small number of possibilities (generally three or fewer), you can annotate the return type with <code>Union{...}</code>. This is generally advantageous only when the intersection of what inference already knows about the types of a variable and the types in the <code>Union</code> results in an concrete type.</p><p>As a more detailed example, suppose you&#39;re writing code that parses Julia&#39;s <code>Expr</code> type:</p><pre><code class="language-julia hljs">julia&gt; ex = :(Array{Float32,3})
:(Array{Float32, 3})

julia&gt; dump(ex)
Expr
  head: Symbol curly
  args: Vector{Any(3,))
    1: Symbol Array
    2: Symbol Float32
    3: Int64 3</code></pre><p><code>ex.args</code> is a <code>Vector{Any}</code>. However, for a <code>:curly</code> expression only certain types will be found among the arguments; you could write key portions of your code as</p><pre><code class="language-julia hljs">a = ex.args[2]
if a isa Symbol
    # inside this block, Julia knows `a` is a Symbol, and so methods called on `a` will be resistant to invalidation
    foo(a)
elseif a isa Expr &amp;&amp; length((a::Expr).args) &gt; 2
    a::Expr         # sometimes you have to help inference by adding a type-assert
    x = bar(a)      # `bar` is now resistant to invalidation
elseif a isa Integer
    # even though you&#39;ve not made this fully-inferrable, you&#39;ve at least reduced the scope for invalidations
    # by limiting the subset of `foobar` methods that might be called
    y = foobar(a)
end</code></pre><p>Other tricks include replacing broadcasting on <code>v::Vector{Any}</code> with <code>Base.mapany(f, v)</code>–<code>mapany</code> avoids trying to narrow the type of <code>f(v[i])</code> and just assumes it will be <code>Any</code>, thereby avoiding invalidations of many <code>convert</code> methods.</p><p>Adding type-assertions and fixing inference problems are the most common approaches for fixing invalidations. You can discover these manually, but using Cthulhu is highly recommended.</p><h2 id="Inferrable-field-access-for-abstract-types"><a class="docs-heading-anchor" href="#Inferrable-field-access-for-abstract-types">Inferrable field access for abstract types</a><a id="Inferrable-field-access-for-abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Inferrable-field-access-for-abstract-types" title="Permalink"></a></h2><p>When invalidations happen for methods that manipulate fields of abstract types, often there is a simple solution: create an &quot;interface&quot; for the abstract type specifying that certain fields must have certain types. Here&#39;s an example:</p><pre><code class="nohighlight hljs">abstract type AbstractDisplay end

struct Monitor &lt;: AbstractDisplay
    height::Int
    width::Int
    maker::String
end

struct Phone &lt;: AbstractDisplay
    height::Int
    width::Int
    maker::Symbol
end

function Base.show(@nospecialize(d::AbstractDisplay), x)
    str = string(x)
    w = d.width
    if length(str) &gt; w  # do we have to truncate to fit the display width?
        ...</code></pre><p>In this <code>show</code> method, we&#39;ve deliberately chosen to prevent specialization on the specific type of <code>AbstractDisplay</code> (to reduce the total number of times we have to compile this method). As a consequence, Julia&#39;s inference may not realize that <code>d.width</code> returns an <code>Int</code>.</p><p>Fortunately, you can help by defining an interface for generic <code>AbstractDisplay</code> objects:</p><pre><code class="nohighlight hljs">function Base.getproperty(d::AbstractDisplay, name::Symbol)
    if name === :height
        return getfield(d, :height)::Int
    elseif name === :width
        return getfield(d, :width)::Int
    elseif name === :maker
        return getfield(d, :maker)::Union{String,Symbol}
    end
    return getfield(d, name)
end</code></pre><p>Julia&#39;s <a href="https://en.wikipedia.org/wiki/Constant_folding">constant propagation</a> will ensure that most accesses of those fields will be determined at compile-time, so this simple change robustly fixes many inference problems.</p><h2 id="Fixing-Core.Box"><a class="docs-heading-anchor" href="#Fixing-Core.Box">Fixing <code>Core.Box</code></a><a id="Fixing-Core.Box-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-Core.Box" title="Permalink"></a></h2><p><a href="https://github.com/JuliaLang/julia/issues/15276">Julia issue 15276</a> is one of the more surprising forms of inference failure; it is the most common cause of a <code>Core.Box</code> annotation. If other variables depend on the <code>Box</code>ed variable, then a single <code>Core.Box</code> can lead to widespread inference problems. For this reason, these are also among the first inference problems you should tackle.</p><p>Read <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured">this explanation of why this happens and what you can do to fix it</a>. If you are directed to find <code>Core.Box</code> inference triggers via <a href="../../reference/#SnoopCompile.suggest"><code>suggest</code></a>, you may need to explore around the call site a bit– the inference trigger may be in the closure itself, but the fix needs to go in the method that creates the closure.</p><p>Use of <code>ascend</code> is highly recommended for fixing <code>Core.Box</code> inference failures.</p><h2 id="Handling-edge-cases"><a class="docs-heading-anchor" href="#Handling-edge-cases">Handling edge cases</a><a id="Handling-edge-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-edge-cases" title="Permalink"></a></h2><p>You can sometimes get invalidations from failing to handle &quot;formal&quot; possibilities. For example, operations with regular expressions might return a <code>Union{Nothing, RegexMatch}</code>. You can sometimes get poor type inference by writing code that fails to take account of the possibility that <code>nothing</code> might be returned. For example, a comprehension</p><pre><code class="language-julia hljs">ms = [m.match for m in match.((rex,), my_strings)]</code></pre><p>might be replaced with</p><pre><code class="language-julia hljs">ms = [m.match for m in match.((rex,), my_strings) if m !== nothing]</code></pre><p>and return a better-typed result.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gotchas/">« Precompilation &quot;gotcha&quot;s</a><a class="docs-footer-nextpage" href="../../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 23 July 2024 16:22">Tuesday 23 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
