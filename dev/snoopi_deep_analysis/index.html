<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using @snoopi_deep results to improve inferrability · SnoopCompile</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SnoopCompile</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><a class="tocitem" href="../snoop_pc/">SnoopPrecompile</a></li><li><a class="tocitem" href="../tutorial/">Tutorial on the foundations</a></li><li><span class="tocitem">Modern tools</span><ul><li><a class="tocitem" href="../snoopr/">Snooping on and fixing invalidations: <code>@snoopr</code></a></li><li><a class="tocitem" href="../snoopi_deep/">Snooping on inference: <code>@snoopi_deep</code></a></li><li><a class="tocitem" href="../pgdsgui/">Profile-guided despecialization</a></li><li class="is-active"><a class="tocitem" href>Using <code>@snoopi_deep</code> results to improve inferrability</a><ul class="internal"><li><a class="tocitem" href="#Analyzing-inference-triggers"><span>Analyzing inference triggers</span></a></li><li><a class="tocitem" href="#test-suites"><span>A note on analyzing test suites</span></a></li><li><a class="tocitem" href="#Results-from-the-improvements"><span>Results from the improvements</span></a></li></ul></li><li><a class="tocitem" href="../snoopi_deep_parcel/">Using <code>@snoopi_deep</code> results for precompilation</a></li><li><a class="tocitem" href="../jet/">JET integration</a></li></ul></li><li><span class="tocitem">Older tools</span><ul><li><a class="tocitem" href="../snoopi/">Snooping on inference: <code>@snoopi</code></a></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li></ul></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modern tools</a></li><li class="is-active"><a href>Using <code>@snoopi_deep</code> results to improve inferrability</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using <code>@snoopi_deep</code> results to improve inferrability</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/snoopi_deep_analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="inferrability"><a class="docs-heading-anchor" href="#inferrability">Using <code>@snoopi_deep</code> results to improve inferrability</a><a id="inferrability-1"></a><a class="docs-heading-anchor-permalink" href="#inferrability" title="Permalink"></a></h1><p>As indicated in the <a href="../#workflow">workflow</a>, the recommended steps to reduce latency are:</p><ul><li>check for invalidations</li><li>adjust method specialization in your package or its dependencies</li><li>fix problems in type inference</li><li>add <code>precompile</code> directives</li></ul><p>The importance of fixing &quot;problems&quot; in type-inference was indicated in the <a href="../tutorial/#tutorial">tutorial</a>: successful precompilation requires a chain of ownership, but runtime dispatch (when inference cannot predict the callee) results in breaks in this chain.  By improving inferrability, you can convert short, unconnected call-trees into a smaller number of large call-trees that all link back to your package(s).</p><p>In practice, it also turns out that opportunities to adjust specialization are often revealed by analyzing inference failures, so this page is complementary to the previous one.</p><p>Finally, improving inference may also yield improvements in runtime performance, itself an excellent outcome.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="https://aviatesk.github.io/JET.jl/dev/optanalysis/">JET also detects inference failures</a>, but JET and SnoopCompile use different mechanisms: JET performs <em>static</em> analysis of a particular call, while SnoopCompile performs <em>dynamic</em> analysis of new inference. As a consequence, JET&#39;s detection of inference failures is reproducible (you can run the same analysis repeatedly and get the same result) but terminates at any non-inferrable node of the call graph: you will miss runtime dispatch in any non-inferrable callees. Conversely, SnoopCompile&#39;s detection of inference failures can explore the entire callgraph, but only for those portions that have not been previously inferred, and the analysis cannot be repeated in the same session.</p></div></div><p>Throughout this page, we&#39;ll use the <code>OptimizeMe</code> demo, which ships with <code>SnoopCompile</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To understand what follows, it&#39;s essential to refer to <a href="https://github.com/timholy/SnoopCompile.jl/blob/master/examples/OptimizeMe.jl"><code>OptimizeMe</code> source code</a> as you follow along.</p></div></div><pre><code class="language-julia hljs">julia&gt; using SnoopCompile

julia&gt; cd(joinpath(pkgdir(SnoopCompile), &quot;examples&quot;))

julia&gt; include(&quot;OptimizeMe.jl&quot;)
Main.OptimizeMe

julia&gt; tinf = @snoopi_deep OptimizeMe.main()
lotsa containers:
7-element Vector{Main.OptimizeMe.Container}:
 Main.OptimizeMe.Container{Int64}(1)
 Main.OptimizeMe.Container{UInt8}(0x01)
 Main.OptimizeMe.Container{UInt16}(0xffff)
 Main.OptimizeMe.Container{Float32}(2.0f0)
 Main.OptimizeMe.Container{Char}(&#39;a&#39;)
 Main.OptimizeMe.Container{Vector{Int64}}([0])
 Main.OptimizeMe.Container{Tuple{String, Int64}}((&quot;key&quot;, 42))
3.14 is great
2.718 is jealous
6-element Vector{Main.OptimizeMe.Object}:
 Main.OptimizeMe.Object(1)
 Main.OptimizeMe.Object(2)
 Main.OptimizeMe.Object(3)
 Main.OptimizeMe.Object(4)
 Main.OptimizeMe.Object(5)
 Main.OptimizeMe.Object(7)
InferenceTimingNode: 1.423913/2.713560 on InferenceFrameInfo for Core.Compiler.Timings.ROOT() with 77 direct children

julia&gt; fg = flamegraph(tinf)
Node(FlameGraphs.NodeData(ROOT() at typeinfer.jl:75, 0x00, 0:2713559552))</code></pre><p>If you visualize <code>fg</code> with ProfileView, you&#39;ll see something like this:</p><p><img src="../assets/flamegraph-OptimizeMe.png" alt="flamegraph-OptimizeMe"/></p><p>From the standpoint of precompilation, this has some obvious problems:</p><ul><li>even though we called a single method, <code>OptimizeMe.main()</code>, there are many distinct flames separated by blank spaces. This indicates that many calls are being made by runtime dispatch:  each separate flame is a fresh entrance into inference.</li><li>several of the flames are marked in red, indicating that they are not precompilable. While SnoopCompile does have the capability to automatically emit <code>precompile</code> directives for the non-red bars that sit on top of the red ones, in some cases the red extends to the highest part of the flame. In such cases there is no available precompile directive, and therefore no way to avoid the cost of type-inference.</li></ul><p>Our goal will be to improve the design of <code>OptimizeMe</code> to make it more precompilable.</p><h2 id="Analyzing-inference-triggers"><a class="docs-heading-anchor" href="#Analyzing-inference-triggers">Analyzing inference triggers</a><a id="Analyzing-inference-triggers-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-inference-triggers" title="Permalink"></a></h2><p>We&#39;ll first extract the &quot;triggers&quot; of inference, which is just a repackaging of part of the information contained within <code>tinf</code>. Specifically an <a href="../reference/#SnoopCompile.InferenceTrigger"><code>InferenceTrigger</code></a> captures callee/caller relationships that straddle a fresh entrance to type-inference, allowing you to identify which calls were made by runtime dispatch and what <code>MethodInstance</code> they called.</p><pre><code class="language-julia hljs">julia&gt; itrigs = inference_triggers(tinf)
76-element Vector{InferenceTrigger}:
 Inference triggered to call MethodInstance for vect(::Int64, ::Vararg{Any, N} where N) from lotsa_containers (/pathto/SnoopCompile/examples/OptimizeMe.jl:13) with specialization MethodInstance for lotsa_containers()
 Inference triggered to call MethodInstance for promote_typeof(::Int64, ::UInt8, ::Vararg{Any, N} where N) from vect (./array.jl:126) with specialization MethodInstance for vect(::Int64, ::Vararg{Any, N} where N)
 Inference triggered to call MethodInstance for promote_typeof(::UInt8, ::UInt16, ::Vararg{Any, N} where N) from promote_typeof (./promotion.jl:272) with specialization MethodInstance for promote_typeof(::Int64, ::UInt8, ::Vararg{Any, N} where N)
 ⋮</code></pre><p>This indicates that a whopping 76 calls were (1) made by runtime dispatch and (2) the callee had not previously been inferred. (There was a 77th call that had to be inferred, the original call to <code>main()</code>, but by default <a href="../reference/#SnoopCompile.inference_triggers"><code>inference_triggers</code></a> excludes calls made directly from top-level. You can change that through keyword arguments.)</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In the REPL, <code>SnoopCompile</code> displays <code>InferenceTrigger</code>s with yellow coloration for the callee, red for the caller method, and blue for the caller specialization. This makes it easier to quickly identify the most important information.</p></div></div><p>In some cases, this might indicate that you&#39;ll need to fix 76 separate callers; fortunately, in many cases fixing the origin of inference problems can fix a number of later callees.</p><h3 id="methtrigs"><a class="docs-heading-anchor" href="#methtrigs">Method triggers</a><a id="methtrigs-1"></a><a class="docs-heading-anchor-permalink" href="#methtrigs" title="Permalink"></a></h3><p>Most often, it&#39;s most convenient to organize them by the method triggering the need for inference:</p><pre><code class="language-julia hljs">julia&gt; mtrigs = accumulate_by_source(Method, itrigs)
18-element Vector{SnoopCompile.TaggedTriggers{Method}}:
 print_matrix_row(io::IO, X::AbstractVecOrMat{T} where T, A::Vector{T} where T, i::Integer, cols::AbstractVector{T} where T, sep::AbstractString) in Base at arrayshow.jl:96 (1 callees from 1 callers)
 show(io::IO, x::T, forceuntyped::Bool, fromprint::Bool) where T&lt;:Union{Float16, Float32, Float64} in Base.Ryu at ryu/Ryu.jl:111 (1 callees from 1 callers)
 Pair(a, b) in Base at pair.jl:15 (1 callees from 1 callers)
 vect(X...) in Base at array.jl:125 (1 callees from 1 callers)
 makeobjects() in Main.OptimizeMe at /pathto/SnoopCompile/examples/OptimizeMe.jl:36 (1 callees from 1 callers)
 show_delim_array(io::IO, itr, op, delim, cl, delim_one, i1, n) in Base at show.jl:1058 (1 callees from 1 callers)
 typeinfo_prefix(io::IO, X) in Base at arrayshow.jl:515 (2 callees from 1 callers)
 (::REPL.var&quot;#38#39&quot;)(io) in REPL at /home/tim/src/julia-master/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:214 (2 callees from 1 callers)
 _cat_t(dims, ::Type{T}, X...) where T in Base at abstractarray.jl:1633 (2 callees from 1 callers)
 contain_list(list) in Main.OptimizeMe at /pathto/SnoopCompile/examples/OptimizeMe.jl:27 (4 callees from 1 callers)
 promote_typeof(x, xs...) in Base at promotion.jl:272 (4 callees from 4 callers)
 combine_eltypes(f, args::Tuple) in Base.Broadcast at broadcast.jl:740 (5 callees from 1 callers)
 lotsa_containers() in Main.OptimizeMe at /pathto/SnoopCompile/examples/OptimizeMe.jl:12 (7 callees from 1 callers)
 alignment(io::IO, x) in Base at show.jl:2528 (7 callees from 7 callers)
 var&quot;#sprint#386&quot;(context, sizehint::Integer, ::typeof(sprint), f::Function, args...) in Base at strings/io.jl:100 (8 callees from 2 callers)
 alignment(io::IO, X::AbstractVecOrMat{T} where T, rows::AbstractVector{T} where T, cols::AbstractVector{T} where T, cols_if_complete::Integer, cols_otherwise::Integer, sep::Integer) in Base at arrayshow.jl:60 (8 callees from 2 callers)
 copyto_nonleaf!(dest, bc::Base.Broadcast.Broadcasted, iter, state, count) in Base.Broadcast at broadcast.jl:1070 (9 callees from 3 callers)
 _show_default(io::IO, x) in Base at show.jl:397 (12 callees from 1 callers)</code></pre><p>The methods triggering the largest number of inference runs are shown at the bottom. You can select methods from a particular module:</p><pre><code class="language-julia hljs">julia&gt; modtrigs = filtermod(OptimizeMe, mtrigs)
3-element Vector{SnoopCompile.TaggedTriggers{Method}}:
 makeobjects() in Main.OptimizeMe at /home/tim/.julia/dev/SnoopCompile/examples/OptimizeMe.jl:36 (1 callees from 1 callers)
 contain_list(list) in Main.OptimizeMe at /home/tim/.julia/dev/SnoopCompile/examples/OptimizeMe.jl:27 (4 callees from 1 callers)
 lotsa_containers() in Main.OptimizeMe at /home/tim/.julia/dev/SnoopCompile/examples/OptimizeMe.jl:12 (7 callees from 1 callers)</code></pre><p>Rather than filter by a single module, you can alternatively call <code>SnoopCompile.parcel(mtrigs)</code> to split them out by module. In this case, most of the triggers came from <code>Base</code>, not <code>OptimizeMe</code>. However, many of the failures in <code>Base</code> were nevertheless indirectly due to <code>OptimizeMe</code>: our methods in <code>OptimizeMe</code> call <code>Base</code> methods with arguments that trigger internal inference failures. Fortunately, we&#39;ll see that using more careful design in <code>OptimizeMe</code> can avoid many of those problems.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you have a longer list of inference triggers than you feel comfortable tackling, filtering by your package&#39;s module is probably the best way to start. Fixing issues in the package itself can end up resolving many of the &quot;indirect&quot; triggers too. Also be sure to note the ability to filter out likely &quot;noise&quot; from <a href="#test-suites">test suites</a>.</p></div></div><p>If you&#39;re hoping to fix inference problems, one of the most efficient things you can do is call <code>summary</code>:</p><pre><code class="language-julia hljs">julia&gt; mtrig = modtrigs[1]
makeobjects() in Main.OptimizeMe at /home/tim/.julia/dev/SnoopCompile/examples/OptimizeMe.jl:36 (1 callees from 1 callers)

julia&gt; summary(mtrig)
makeobjects() in Main.OptimizeMe at /home/tim/.julia/dev/SnoopCompile/examples/OptimizeMe.jl:36 had 1 specializations
Triggering calls:
Inlined _cat at ./abstractarray.jl:1630: calling cat_t##kw (1 instances)</code></pre><p>Sometimes from these hints alone you can figure out how to fix the problem. (<code>Inlined _cat</code> means that the inference trigger did not come directly from a source line of <code>makeobjects</code> but from a call, <code>_cat</code>, that got inlined into the compiled version. Below we&#39;ll see more concretely how to interpret this hint.)</p><p>You can also say <code>edit(mtrig)</code> and be taken directly to the method you&#39;re analyzing in your editor. Finally, you can recover the individual triggers:</p><pre><code class="language-julia hljs">julia&gt; mtrig.itrigs[1]
Inference triggered to call MethodInstance for (::Base.var&quot;#cat_t##kw&quot;)(::NamedTuple{(:dims,), Tuple{Val{1}}}, ::typeof(Base.cat_t), ::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N) from _cat (./abstractarray.jl:1630) inlined into MethodInstance for makeobjects() (/home/tim/.julia/dev/SnoopCompile/examples/OptimizeMe.jl:37)</code></pre><p>This is useful if you want to analyze a method via <a href="#ascend-itrig"><code>ascend</code></a>. <code>Method</code>-based triggers, which may aggregate many different individual triggers, are particularly useful mostly because tools like <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a> show you the inference results for the entire <code>MethodInstance</code>, allowing you to fix many different inference problems at once.</p><h3 id="Trigger-trees"><a class="docs-heading-anchor" href="#Trigger-trees">Trigger trees</a><a id="Trigger-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Trigger-trees" title="Permalink"></a></h3><p>While method triggers are probably the most useful way of organizing these inference triggers, for learning purposes here we&#39;ll use a more detailed scheme, which organizes inference triggers in a tree:</p><pre><code class="language-julia hljs">julia&gt; itree = trigger_tree(itrigs)
TriggerNode for root with 14 direct children

julia&gt; using AbstractTrees

julia&gt; print_tree(itree)
root
├─ MethodInstance for vect(::Int64, ::Vararg{Any, N} where N)
│  └─ MethodInstance for promote_typeof(::Int64, ::UInt8, ::Vararg{Any, N} where N)
│     └─ MethodInstance for promote_typeof(::UInt8, ::UInt16, ::Vararg{Any, N} where N)
│        └─ MethodInstance for promote_typeof(::UInt16, ::Float32, ::Vararg{Any, N} where N)
│           └─ MethodInstance for promote_typeof(::Float32, ::Char, ::Vararg{Any, N} where N)
│              ⋮
│
├─ MethodInstance for combine_eltypes(::Type, ::Tuple{Vector{Any}})
│  ├─ MethodInstance for return_type(::Any, ::Any)
│  ├─ MethodInstance for return_type(::Any, ::Any, ::UInt64)
│  ├─ MethodInstance for return_type(::Core.Compiler.NativeInterpreter, ::Any, ::Any)
│  ├─ MethodInstance for contains_is(::Core.SimpleVector, ::Any)
│  └─ MethodInstance for promote_typejoin_union(::Type{Main.OptimizeMe.Container})
├─ MethodInstance for Main.OptimizeMe.Container(::Int64)
⋮</code></pre><p>The parent-child relationships are based on the backtraces at the entrance to inference, and the nodes are organized in the order in which inference occurred.</p><p>We&#39;re going to march through these systematically. Let&#39;s start with the first of these.</p><h3 id="suggest-and-a-fix-involving-manual-eltype-specification"><a class="docs-heading-anchor" href="#suggest-and-a-fix-involving-manual-eltype-specification"><code>suggest</code> and a fix involving manual <code>eltype</code> specification</a><a id="suggest-and-a-fix-involving-manual-eltype-specification-1"></a><a class="docs-heading-anchor-permalink" href="#suggest-and-a-fix-involving-manual-eltype-specification" title="Permalink"></a></h3><p>Because the analysis of inference failures is somewhat complex, <code>SnoopCompile</code> attempts to <a href="../reference/#SnoopCompile.suggest"><code>suggest</code></a> an interpretation and/or remedy for each trigger:</p><pre><code class="nohighlight hljs">julia&gt; suggest(itree.children[1])
/pathto/SnoopCompile/examples/OptimizeMe.jl:13: invoked callee is varargs (ignore this one, homogenize the arguments, declare an umbrella type, or force-specialize the callee MethodInstance for vect(::Int64, ::Vararg{Any, N} where N))
immediate caller(s):
1-element Vector{Base.StackTraces.StackFrame}:
 main() at OptimizeMe.jl:42
└─ ./array.jl:126: caller is varargs (ignore this one, specialize the caller vect(::Int64, ::Vararg{Any, N} where N) at array.jl:126, or improve inferrability of its caller)
   immediate caller(s):
   1-element Vector{Base.StackTraces.StackFrame}:
    lotsa_containers() at OptimizeMe.jl:13
   └─ ./promotion.jl:272: caller is varargs (ignore this one, specialize the caller promote_typeof(::Int64, ::UInt8, ::Vararg{Any, N} where N) at promotion.jl:272, or improve inferrability of its caller)
      immediate caller(s):
      1-element Vector{Base.StackTraces.StackFrame}:
       vect(::Int64, ::Vararg{Any, N} where N) at array.jl:126
      └─ ./promotion.jl:272: caller is varargs (ignore this one, specialize the caller promote_typeof(::UInt8, ::UInt16, ::Vararg{Any, N} where N) at promotion.jl:272, or improve inferrability of its caller)
         immediate caller(s):
         1-element Vector{Base.StackTraces.StackFrame}:
          promote_typeof(::Int64, ::UInt8, ::Vararg{Any, N} where N) at promotion.jl:272
         └─ ./promotion.jl:272: caller is varargs (ignore this one, specialize the caller promote_typeof(::UInt16, ::Float32, ::Vararg{Any, N} where N) at promotion.jl:272, or improve inferrability of its caller)
            immediate caller(s):
            1-element Vector{Base.StackTraces.StackFrame}:
             promote_typeof(::UInt8, ::UInt16, ::Vararg{Any, N} where N) at promotion.jl:272
            └─ ./promotion.jl:272: caller is varargs (ignore this one, specialize the caller promote_typeof(::Float32, ::Char, ::Vararg{Any, N} where N) at promotion.jl:272, or improve inferrability of its caller)
               immediate caller(s):
               1-element Vector{Base.StackTraces.StackFrame}:
                promote_typeof(::UInt16, ::Float32, ::Vararg{Any, N} where N) at promotion.jl:272
               ⋮</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In the REPL, interpretations are highlighted in color to help distinguish individual suggestions.</p></div></div><p>In this case, the interpretation for the first node is &quot;invoked callee is varargs&quot; and suggestions are to choose one of &quot;ignore...homogenize...umbrella type...force-specialize&quot;. Initially, this may seem pretty opaque. It helps if we look at the referenced line <code>OptimizeMe.jl:13</code>:</p><pre><code class="language-julia hljs">list = [1, 0x01, 0xffff, 2.0f0, &#39;a&#39;, [0], (&quot;key&quot;, 42)]</code></pre><p>You&#39;ll notice above that the callee for the first node is <code>vect</code>; that&#39;s what handles the creation of the vector <code>[1, ...]</code>. If you look back up at the <code>itree</code>, you can see that a lot of <code>promote_typeof</code> calls follow, and you can see that the types listed in the arguments match the elements in <code>list</code>. The problem, here, is that <code>vect</code> has never been inferred for this particular combination of argument types, and the fact that the types are diverse means that Julia has decided not to specialize it for this combination. (If Julia had specialized it, it would have been inferred when <code>lotsa_containers</code> was inferred; the fact that it is showing up as a trigger means it wasn&#39;t.)</p><p>Let&#39;s see what kind of object this line creates:</p><pre><code class="language-julia hljs">julia&gt; typeof(list)
Vector{Any} (alias for Array{Any, 1})</code></pre><p>Since it creates a <code>Vector{Any}</code>, perhaps we should just tell Julia to create such an object directly: we modify <code>[1, 0x01, ...]</code> to <code>Any[1, 0x01, ...]</code> (note the <code>Any</code> in front of <code>[</code>), so that Julia doesn&#39;t have to deduce the container type on its own. This follows the &quot;declare an umbrella type&quot; suggestion.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>&quot;Force-specialize&quot; means to encourage Julia to violate its heuristics and specialize the callee. Often this can be achieved by supplying a &quot;spurious&quot; type parameter. Examples include replacing <code>higherorderfunction(f::Function, args...)</code> with <code>function higherorderfunction(f::F, args...) where F&lt;:Function</code>, or <code>function getindex(A::MyArrayType{T,N}, idxs::Vararg{Int,N}) where {T,N}</code> instead of just <code>getindex(A::MyArrayType, idxs::Int...)</code>. (In the latter case, the <code>N</code> parameter is the crucial one: it forces specialization for a particular number of <code>Int</code> arguments.)</p><p>This technique is not useful for the particular case we analyzed here, but it can be in other settings.</p></div></div><p>Making this simple 3-character fix eliminates that entire branch of the tree (a savings of 6 inference triggers).</p><h3 id="eltypes-and-reducing-specialization-in-broadcast"><a class="docs-heading-anchor" href="#eltypes-and-reducing-specialization-in-broadcast"><code>eltype</code>s and reducing specialization in <code>broadcast</code></a><a id="eltypes-and-reducing-specialization-in-broadcast-1"></a><a class="docs-heading-anchor-permalink" href="#eltypes-and-reducing-specialization-in-broadcast" title="Permalink"></a></h3><p>Let&#39;s move on to the next entry:</p><pre><code class="nohighlight hljs">julia&gt; print_tree(itree.children[2])
MethodInstance for combine_eltypes(::Type, ::Tuple{Vector{Any}})
├─ MethodInstance for return_type(::Any, ::Any)
├─ MethodInstance for return_type(::Any, ::Any, ::UInt64)
├─ MethodInstance for return_type(::Core.Compiler.NativeInterpreter, ::Any, ::Any)
├─ MethodInstance for contains_is(::Core.SimpleVector, ::Any)
└─ MethodInstance for promote_typejoin_union(::Type{Main.OptimizeMe.Container})

julia&gt; suggest(itree.children[2])
./broadcast.jl:905: regular invoke (perhaps precompile lotsa_containers() at OptimizeMe.jl:14)
├─ ./broadcast.jl:740: I&#39;ve got nothing to say for MethodInstance for return_type(::Any, ::Any) consider `stacktrace(itrig)` or `ascend(itrig)`
├─ ./broadcast.jl:740: I&#39;ve got nothing to say for MethodInstance for return_type(::Any, ::Any, ::UInt64) consider `stacktrace(itrig)` or `ascend(itrig)`
├─ ./broadcast.jl:740: I&#39;ve got nothing to say for MethodInstance for return_type(::Core.Compiler.NativeInterpreter, ::Any, ::Any) consider `stacktrace(itrig)` or `ascend(itrig)`
├─ ./broadcast.jl:740: I&#39;ve got nothing to say for MethodInstance for contains_is(::Core.SimpleVector, ::Any) consider `stacktrace(itrig)` or `ascend(itrig)`
└─ ./broadcast.jl:740: non-inferrable call, perhaps annotate combine_eltypes(f, args::Tuple) in Base.Broadcast at broadcast.jl:740 with type MethodInstance for promote_typejoin_union(::Type{Main.OptimizeMe.Container})
   If a noninferrable argument is a type or function, Julia&#39;s specialization heuristics may be responsible.
   immediate caller(s):
   3-element Vector{Base.StackTraces.StackFrame}:
    copy at broadcast.jl:905 [inlined]
    materialize at broadcast.jl:883 [inlined]
    lotsa_containers() at OptimizeMe.jl:14</code></pre><p>While this tree is attributed to <code>broadcast</code>, you can see several references here to <code>OptimizeMe.jl:14</code>, which contains:</p><pre><code class="language-julia hljs">cs = Container.(list)</code></pre><p><code>Container.(list)</code> is a broadcasting operation, and once again we find that this has inferrability problems. In this case, the initial suggestion &quot;perhaps precompile <code>lotsa_containers</code>&quot; is <em>not</em> helpful. (The &quot;regular invoke&quot; just means that the initial call was one where inference knew all the argument types, and hence in principle might be precompilable, but from this tree we see that this broke down in some of its callees.) Several children have no interpretation (&quot;I&#39;ve got nothing to say...&quot;). Only the last one, &quot;non-inferrable call&quot;, is (marginally) useful, it means that a call was made with arguments whose types could not be inferred.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>You should always view these suggestions skeptically. Often, they flag downstream issues that are better addressed at the source; frequently the best fix may be at a line a bit before the one identified in a trigger, or even in a dependent callee of a line prior to the flagged one. This is a product of the fact that <em>returning</em> a non-inferrable argument is not the thing that forces a new round of inference; it&#39;s <em>doing something</em> (making a specialization-worthy call) with the object of non-inferrable type that triggers a fresh entrance into inference.</p></div></div><p>How might we go about fixing this? One hint is to notice that <code>itree.children[3]</code> through <code>itree.children[7]</code> also ultimiately derive from this one line of <code>OptimizeMe</code>, but from a later line within <code>broadcast.jl</code> which explains why they are not bundled together with <code>itree.children[2]</code>. May of these correspond to creating different <code>Container</code> types, for example:</p><pre><code class="nohighlight hljs">└─ MethodInstance for restart_copyto_nonleaf!(::Vector{Main.OptimizeMe.Container}, ::Vector{Main.OptimizeMe.Container{Int64}}, ::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, Type{Main.OptimizeMe.Container}, Tuple{Base.Broadcast.Extruded{Vector{Any}, Tuple{Bool}, Tuple{Int64}}}}, ::Main.OptimizeMe.Container{UInt8}, ::Int64, ::Base.OneTo{Int64}, ::Int64, ::Int64)
   ├─ MethodInstance for Main.OptimizeMe.Container(::UInt16)
   ├─ MethodInstance for Main.OptimizeMe.Container(::Float32)
   ├─ MethodInstance for Main.OptimizeMe.Container(::Char)
   ├─ MethodInstance for Main.OptimizeMe.Container(::Vector{Int64})
   └─ MethodInstance for Main.OptimizeMe.Container(::Tuple{String, Int64})</code></pre><p>We&#39;ve created a <code>Container{T}</code> for each specific <code>T</code> of the objects in <code>list</code>. In some cases, there may be good reasons for such specialization, and in such cases we just have to live with these inference failures. However, in other cases the specialization might be detrimental to compile-time and/or runtime performance. In such cases, we might decide to create them all as <code>Container{Any}</code>:</p><pre><code class="language-julia hljs">cs = Container{Any}.(list)</code></pre><p>This 5-character change ends up eliminating 45 of our original 76 triggers. Not only did we eliminate the triggers from broadcasting, but we limited the number of different <code>show(::IO, ::Container{T})</code>-<code>MethodInstance</code>s we need from later calls in <code>main</code>.</p><p>When the <code>Container</code> constructor does more complex operations, in some cases you may find that <code>Container{Any}(args...)</code> still gets specialized for different types of <code>args...</code>. In such cases, you can create a special constructor that instructs Julia to avoid specialization in specific instances, e.g.,</p><pre><code class="language-julia hljs">struct Container{T}
    field1::T
    morefields...

    # This constructor permits specialization on `args`
    Container{T}(args...) where {T} = new{T}(args...)

    # For Container{Any}, we prevent specialization
    Container{Any}(@nospecialize(args...)) = new{Any}(args...)
end</code></pre><p>If you&#39;re following along, the best option is to make these fixes and go back to the beginning, re-collecting <code>tinf</code> and processing the triggers. We&#39;re down to 32 inference triggers.</p><h3 id="typeasserts"><a class="docs-heading-anchor" href="#typeasserts">Adding type-assertions</a><a id="typeasserts-1"></a><a class="docs-heading-anchor-permalink" href="#typeasserts" title="Permalink"></a></h3><p>If you&#39;ve made the fixes above, the first child of <code>itree</code> is one for <code>show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMe.Container{Any}})</code>; we&#39;ll skip that one for now, because it&#39;s a bit more sophisticated. Right below it, we see</p><pre><code class="nohighlight hljs">├─ MethodInstance for combine_eltypes(::Type, ::Tuple{Vector{Any}})
│  ├─ MethodInstance for return_type(::Any, ::Any)
│  ├─ MethodInstance for return_type(::Any, ::Any, ::UInt64)</code></pre><p>and related nodes for <code>similar</code>, <code>copyto_nonleaf!</code>, etc., just as we saw above, so this looks like another case of broadcasting failure. In this case, <code>suggest</code> quickly indicates that it&#39;s the broadcasting in</p><pre><code class="language-julia hljs">function contain_list(list)
    cs = Container.(list)
    return concat_string(cs...)
end</code></pre><p>Now we know the problem: <code>main</code> creates <code>list = [2.718, &quot;is jealous&quot;]</code>, a vector with different object types, and this leads to inference failures in broadcasting. But wait, you might notice, <code>contain_concrete</code> gets called before <code>contain_list</code>, why doesn&#39;t it have a problem? The reason is that <code>contain_concrete</code> and its callee, <code>concat_string</code>, provide opportunities for inference to handle each object in a separate argument; the problems arise from bundling objects of different types into the same container.</p><p>There are several ways we could go about fixig this example:</p><ul><li>we could delete <code>contain_list</code> altogether and use <code>contain_concrete</code> for everything.</li><li>we could try creating <code>list</code> as a tuple rather than a <code>Vector{Any}</code>; (small) tuples sometimes allow inference to succeed even when each element has a different type. This is as simple as changing <code>list = [2.718, &quot;is jealous&quot;]</code> to <code>list = (2.718, &quot;is jealous&quot;)</code>, but whether it works to solve all your inference problems depends on the particular case.</li><li>we could use external knowledge to annotate the types of the items in <code>list::Vector{Any}</code>.</li></ul><p>Here we&#39;ll illustrate the last of these, since it&#39;s the only one that&#39;s nontrivial. (It&#39;s also often a useful pattern in many real-world contexts, such as cases where you have a <code>Dict{String,Any}</code> but know something about the kinds of value-types associated with particular string keys.) We could rewrite <code>contain_list</code> so it looks like this:</p><pre><code class="language-julia hljs">function contain_list(list)
    length(list) == 2 || throw(DimensionMismatch(&quot;list must have length 2&quot;))
    item1 = list[1]::Float64
    item2 = list[2]::String
    return contain_concrete(item1, item2)     # or we could repeat the body of contain_concrete
end</code></pre><p>The type-assertions tell inference that the corresponding items have the given types, and assist inference in cases where it has no mechanism to deduce the answer on its own. Julia will throw an error if the type-assertion fails. In some cases, a more forgiving option might be</p><pre><code class="language-julia hljs">item1 = convert(Float64, list[1])::Float64</code></pre><p>which will attempt to convert <code>list[1]</code> to a <code>Float64</code>, and therefore handle a wider range of number types stored in the first element of <code>list</code>. Believe it or not, both the <code>convert()</code> and the <code>::Float64</code> type-assertion are necessary: since <code>list[1]</code> is of type <code>Any</code>, Julia will not be able to deduce which <code>convert</code> method will be used to perform the conversion, and it&#39;s always possible that someone has written a sloppy <code>convert</code> that doesn&#39;t return a value of the requested type. Without that final <code>::Float64</code>, inference cannot simply assume that the result is a <code>Float64</code>. The type-assert <code>::Float64</code> enforces the fact that you&#39;re expecting that <code>convert</code> call to actually return a <code>Float64</code>–it will error if it fails to do so, and it&#39;s this error that allows inference to be certain that for the purposes of any later code it must be a <code>Float64</code>.</p><p>Of course, this just trades one form of inference failure for another–the call to <code>convert</code> will be made by runtime dispatch–but this can nevertheless be a big win for two reasons:</p><ul><li>even though the <code>convert</code> call will be made by runtime dispatch, in this particular case <code>convert(Float64, ::Float64)</code> is already compiled in Julia itself.  Consequently it doesn&#39;t require a fresh run of inference.</li><li>even in cases where the types are such that <code>convert</code> might need to be inferred &amp; compiled, the type-assertion allows Julia to assume that <code>item1</code> is henceforth a <code>Float64</code>.  This makes it possible for inference to succeed for any code that follows.  When that&#39;s a large amount of code, the savings can be considerable.</li></ul><p>Let&#39;s make that fix and also annotate the container type from <code>main</code>, <code>list = Any[2.718, &quot;is jealous&quot;]</code>. Just to see how we&#39;re progressing, we start a fresh session and discover we&#39;re down to 20 triggers with just three direct branches.</p><h3 id="Vararg-homogenization"><a class="docs-heading-anchor" href="#Vararg-homogenization">Vararg homogenization</a><a id="Vararg-homogenization-1"></a><a class="docs-heading-anchor-permalink" href="#Vararg-homogenization" title="Permalink"></a></h3><p>We&#39;ll again skip over the <code>show</code> branches (they are two of the remaining three), and focus on this one:</p><pre><code class="language-julia hljs">julia&gt; node = itree.children[2]
TriggerNode for MethodInstance for (::Base.var&quot;#cat_t##kw&quot;)(::NamedTuple{(:dims,), Tuple{Val{1}}}, ::typeof(Base.cat_t), ::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N) with 2 direct children

julia&gt; print_tree(node)
MethodInstance for (::Base.var&quot;#cat_t##kw&quot;)(::NamedTuple{(:dims,), Tuple{Val{1}}}, ::typeof(Base.cat_t), ::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N)
├─ MethodInstance for cat_similar(::UnitRange{Int64}, ::Type, ::Tuple{Int64})
└─ MethodInstance for __cat(::Vector{Int64}, ::Tuple{Int64}, ::Tuple{Bool}, ::UnitRange{Int64}, ::Vararg{Any, N} where N)

julia&gt; suggest(node)
./abstractarray.jl:1630: invoked callee is varargs (ignore this one, force-specialize the callee MethodInstance for (::Base.var&quot;#cat_t##kw&quot;)(::NamedTuple{(:dims,), Tuple{Val{1}}}, ::typeof(Base.cat_t), ::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N), or declare an umbrella type)
immediate caller(s):
1-element Vector{Base.StackTraces.StackFrame}:
 main() at OptimizeMe.jl:48
├─ ./abstractarray.jl:1636: caller is varargs (ignore this one, specialize the caller _cat_t(::Val{1}, ::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N) at abstractarray.jl:1636, or improve inferrability of its caller)
│  immediate caller(s):
│  1-element Vector{Base.StackTraces.StackFrame}:
│   cat_t(::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N; dims::Val{1}) at abstractarray.jl:1632
└─ ./abstractarray.jl:1640: caller is varargs (ignore this one, specialize the caller _cat_t(::Val{1}, ::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N) at abstractarray.jl:1640, or improve inferrability of its caller)
   immediate caller(s):
   1-element Vector{Base.StackTraces.StackFrame}:
    cat_t(::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N; dims::Val{1}) at abstractarray.jl:1632</code></pre><p>Due to Julia&#39;s optimization and inlining, it&#39;s sometimes a bit hard to tell from these shortened displays where a particular trigger comes from. (It turns out that this is finally the trigger we looked at in greatest detail in <a href="#methtrigs">method-based triggers</a>.) In this case we extract the specific trigger and show the stacktrace:</p><pre><code class="language-julia hljs">julia&gt; itrig = node.itrig
Inference triggered to call MethodInstance for (::Base.var&quot;#cat_t##kw&quot;)(::NamedTuple{(:dims,), Tuple{Val{1}}}, ::typeof(Base.cat_t), ::Type{Int64}, ::UnitRange{Int64}, ::Vararg{Any, N} where N) from _cat (./abstractarray.jl:1630) inlined into MethodInstance for makeobjects() (/tmp/OptimizeMe.jl:39)

julia&gt; stacktrace(itrig)
24-element Vector{Base.StackTraces.StackFrame}:
 exit_current_timer at typeinfer.jl:166 [inlined]
 typeinf(interp::Core.Compiler.NativeInterpreter, frame::Core.Compiler.InferenceState) at typeinfer.jl:208
 typeinf_ext(interp::Core.Compiler.NativeInterpreter, mi::Core.MethodInstance) at typeinfer.jl:835
 typeinf_ext_toplevel(interp::Core.Compiler.NativeInterpreter, linfo::Core.MethodInstance) at typeinfer.jl:868
 typeinf_ext_toplevel(mi::Core.MethodInstance, world::UInt64) at typeinfer.jl:864
 _cat at abstractarray.jl:1630 [inlined]
 #cat#127 at abstractarray.jl:1769 [inlined]
 cat at abstractarray.jl:1769 [inlined]
 vcat at abstractarray.jl:1698 [inlined]
 makeobjects() at OptimizeMe.jl:39
 main() at OptimizeMe.jl:48
 top-level scope at snoopi_deep.jl:53
 eval(m::Module, e::Any) at boot.jl:360
 eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139
 repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200
 start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185
 run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317
 run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:305
 (::Base.var&quot;#872#874&quot;{Bool, Bool, Bool})(REPL::Module) at client.jl:387
 #invokelatest#2 at essentials.jl:707 [inlined]
 invokelatest at essentials.jl:706 [inlined]
 run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool) at client.jl:372
 exec_options(opts::Base.JLOptions) at client.jl:302
 _start() at client.jl:485</code></pre><p>(You can also call <code>stacktrace</code> directly on <code>node</code>.) It&#39;s the lines immediately following <code>typeinf_ext_toplevel</code> that need concern us: you can see that the &quot;last stop&quot; on code we wrote here was <code>makeobjects() at OptimizeMe.jl:39</code>, after which it goes fairly deep into the concatenation pipeline before suffering an inference trigger at <code>_cat at abstractarray.jl:1630</code>.</p><p>In this case, the first hint is quite useful, if we know how to interpret it. The <code>invoked callee is varargs</code> reassures us that the immediate caller, <code>_cat</code>, knows exactly which method it is calling (that&#39;s the meaning of the <code>invoked</code>). The real problem is that it doesn&#39;t know how to specialize it. The suggestion to <code>homogenize the arguments</code> is the crucial hint: the problem comes from the fact that in</p><pre><code class="language-julia hljs">xs = [1:5; 7]</code></pre><p><code>1:5</code> is a <code>UnitRange{Int}</code> whereas <code>7</code> is an <code>Int</code>, and the fact that these are two different types prevents Julia from knowing how to specialize that varargs call. But this is easy to fix, because the result will be identical if we write this as</p><pre><code class="language-julia hljs">xs = [1:5; 7:7]</code></pre><p>in which case both arguments are <code>UnitRange{Int}</code>, and this allows Julia to specialize the varargs call.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It&#39;s generally a good thing that Julia doesn&#39;t specialize each and every varargs call, because the lack of specialization reduces latency. However, when you can homogenize the argument types and make it inferrable, you make it more worthy of precompilation, which is a different and ultimately more impactful approach to latency reduction.</p></div></div><h3 id="Defining-show-methods-for-custom-types"><a class="docs-heading-anchor" href="#Defining-show-methods-for-custom-types">Defining <code>show</code> methods for custom types</a><a id="Defining-show-methods-for-custom-types-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-show-methods-for-custom-types" title="Permalink"></a></h3><p>Finally we are left with nodes that are related to <code>show</code>. We&#39;ll temporarily skip the first of these and examine</p><pre><code class="language-julia hljs">julia&gt; print_tree(node)
MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMe.Object})
└─ MethodInstance for var&quot;#sprint#386&quot;(::IOContext{Base.TTY}, ::Int64, ::typeof(sprint), ::Function, ::Main.OptimizeMe.Object)
   └─ MethodInstance for sizeof(::Main.OptimizeMe.Object)</code></pre><p>We&#39;ll use this as an excuse to point out that if you don&#39;t know how to deal with the root node of this (sub)tree, you can tackle later nodes:</p><pre><code class="language-julia hljs">julia&gt; itrigsnode = flatten(node)
3-element Vector{InferenceTrigger}:
 Inference triggered to call MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMe.Object}) from #38 (/home/tim/src/julia-master/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:220) with specialization MethodInstance for (::REPL.var&quot;#38#39&quot;{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(&quot;text/plain&quot;)}, Base.RefValue{Any}})(::Any)
 Inference triggered to call MethodInstance for var&quot;#sprint#386&quot;(::IOContext{Base.TTY}, ::Int64, ::typeof(sprint), ::Function, ::Main.OptimizeMe.Object) from sprint##kw (./strings/io.jl:101) inlined into MethodInstance for alignment(::IOContext{Base.TTY}, ::Vector{Main.OptimizeMe.Object}, ::UnitRange{Int64}, ::UnitRange{Int64}, ::Int64, ::Int64, ::Int64) (./arrayshow.jl:68)
 Inference triggered to call MethodInstance for sizeof(::Main.OptimizeMe.Object) from _show_default (./show.jl:402) with specialization MethodInstance for _show_default(::IOContext{IOBuffer}, ::Any)

julia&gt; itrig = itrigsnode[end]
Inference triggered to call MethodInstance for sizeof(::Main.OptimizeMe.Object) from _show_default (./show.jl:402) with specialization MethodInstance for _show_default(::IOContext{IOBuffer}, ::Any)</code></pre><p>The stacktrace begins</p><pre><code class="language-julia hljs">julia&gt; stacktrace(itrig)
35-element Vector{Base.StackTraces.StackFrame}:
 exit_current_timer at typeinfer.jl:166 [inlined]
 typeinf(interp::Core.Compiler.NativeInterpreter, frame::Core.Compiler.InferenceState) at typeinfer.jl:208
 typeinf_ext(interp::Core.Compiler.NativeInterpreter, mi::Core.MethodInstance) at typeinfer.jl:835
 typeinf_ext_toplevel(interp::Core.Compiler.NativeInterpreter, linfo::Core.MethodInstance) at typeinfer.jl:868
 typeinf_ext_toplevel(mi::Core.MethodInstance, world::UInt64) at typeinfer.jl:864
 _show_default(io::IOContext{IOBuffer}, x::Any) at show.jl:402
 show_default at show.jl:395 [inlined]
 show(io::IOContext{IOBuffer}, x::Any) at show.jl:390
 sprint(f::Function, args::Main.OptimizeMe.Object; context::IOContext{Base.TTY}, sizehint::Int64) at io.jl:103
⋮</code></pre><p>You can see that <code>sprint</code> called <code>show</code> which called <code>_show_default</code>; <code>_show_default</code> clearly needed to call <code>sizeof</code>. The hint, in this case, suggests the impossible:</p><pre><code class="nohighlight hljs">julia&gt; suggest(itrig)
./show.jl:402: non-inferrable call, perhaps annotate _show_default(io::IO, x) in Base at show.jl:397 with type MethodInstance for sizeof(::Main.OptimizeMe.Object)
If a noninferrable argument is a type or function, Julia&#39;s specialization heuristics may be responsible.
immediate caller(s):
2-element Vector{Base.StackTraces.StackFrame}:
 show_default at show.jl:395 [inlined]
 show(io::IOContext{IOBuffer}, x::Any) at show.jl:390</code></pre><p>Because <code>Base</code> doesn&#39;t know about <code>OptimizeMe.Object</code>, you could not add such an annotation, and it wouldn&#39;t be correct in the vast majority of cases.</p><p>As the name implies, <code>_show_default</code> is the fallback <code>show</code> method. We can fix this by adding our own <code>show</code> method</p><pre><code class="language-julia hljs">Base.show(io::IO, o::Object) = print(io, &quot;Object x: &quot;, o.x)</code></pre><p>to the module definition. <code>Object</code> is so simple that this is slightly silly, but in more complex cases adding good <code>show</code> methods improves usability of your packages tremendously. (SnoopCompile has many <code>show</code> specializations, and without them it would be practically unusable.)</p><p>When you do define a custom <code>show</code> method, you own it, so of course it will be precompilable. So we&#39;ve circumvented this particular issue.</p><h3 id="Creating-&quot;warmup&quot;-methods"><a class="docs-heading-anchor" href="#Creating-&quot;warmup&quot;-methods">Creating &quot;warmup&quot; methods</a><a id="Creating-&quot;warmup&quot;-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-&quot;warmup&quot;-methods" title="Permalink"></a></h3><p>Finally, it is time to deal with those long-delayed <code>show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::T)</code> triggers and the triggers they inspire. We have two of them, one for <code>T = Vector{Main.OptimizeMe.Container{Any}}</code> and one for <code>T = Vector{Main.OptimizeMe.Object}</code>. Let&#39;s look at just the trigger associated with the first:</p><pre><code class="nohighlight hljs">julia&gt; itrig
Inference triggered to call MethodInstance for show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Container{Any}}) from #38 (/pathto/julia/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:220) with specialization MethodInstance for (::REPL.var&quot;#38#39&quot;{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(&quot;text/plain&quot;)}, Base.RefValue{Any}})(::Any)</code></pre><p>In this case we see that the method is <code>#38</code>.  This is a <code>gensym</code>, or generated symbol, indicating that the method was generated during Julia&#39;s lowering pass, and might indicate a macro, a <code>do</code> block or other anonymous function, the generator for a <code>@generated</code> function, etc.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It&#39;s particularly worthwhile to improve inferrability for gensym-methods. The number assiged to a gensymmed-method may change as you or other developers modify the package (possibly due to changes at very difference source-code locations), and so any explicit <code>precompile</code> directives involving gensyms may not have a long useful life.</p><p>But not all methods with <code>#</code> in their name are problematic: methods ending in <code>##kw</code> or that look like <code>##funcname#39</code> are <em>keyword</em> and <em>body</em> methods, respectively, for methods that accept keywords.  They can be obtained from the main method, and so <code>precompile</code> directives for such methods will not be outdated by incidental changes to the package.</p></div></div><p><code>edit(itrig)</code> (or equivalently, <code>edit(node)</code> where <code>node</code> is a child of <code>itree</code>) takes us to this method in <code>Base</code>:</p><pre><code class="language-julia hljs">function display(d::REPLDisplay, mime::MIME&quot;text/plain&quot;, x)
    x = Ref{Any}(x)
    with_repl_linfo(d.repl) do io
        io = IOContext(io, :limit =&gt; true, :module =&gt; Main::Module)
        get(io, :color, false) &amp;&amp; write(io, answer_color(d.repl))
        if isdefined(d.repl, :options) &amp;&amp; isdefined(d.repl.options, :iocontext)
            # this can override the :limit property set initially
            io = foldl(IOContext, d.repl.options.iocontext, init=io)
        end
        show(io, mime, x[])
        println(io)
    end
    return nothing
end</code></pre><p>The generated method corresponds to the <code>do</code> block here. The call to <code>show</code> comes from <code>show(io, mime, x[])</code>. This implementation uses a clever trick, wrapping <code>x</code> in a <code>Ref{Any}(x)</code>, to prevent specialization of the method defined by the <code>do</code> block on the specific type of <code>x</code>. This trick is designed to limit the number of <code>MethodInstance</code>s inferred for this <code>display</code> method.</p><p>Unfortunately, from the standpoint of precompilation we have something of a conundrum. It turns out that this trigger corresponds to the first of the big red flames in the flame graph. <code>show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMe.Container{Any}})</code> is not precompilable because <code>Base</code> owns the <code>show</code> method for <code>Vector</code>; we might own the element type, but we&#39;re leveraging the generic machinery in <code>Base</code> and consequently it owns the method. If these were all packages, you might request its developers to add a <code>precompile</code> directive, but that will work only if the package that owns the method knows about the relevant type. In this situation, Julia&#39;s <code>Base</code> module doesn&#39;t know about <code>OptimizeMe.Container{Any}</code>, so we&#39;re stuck.</p><p>There are a couple of ways one might go about improving matters. First, one option is that this should be changed in Julia itself: since the caller, <code>display</code>, has gone to some lengths to reduce specialization, it would be worth contemplating whether <code>show(io::IO, ::MIME&quot;text/plain&quot;, X::AbstractArray)</code> should have a <code>@nospecialize</code> around <code>X</code>. Here, we&#39;ll pursue a simple &quot;cheat,&quot; one that allows us to directly precompile this method. The trick is to link it, via a chain of backedges, to a method that our package owns:</p><pre><code class="language-julia hljs"># &quot;Stub&quot; callers for precompilability (we don&#39;t use this function for any real work)
function warmup()
    mime = MIME(&quot;text/plain&quot;)
    io = Base.stdout::Base.TTY
    # Container{Any}
    v = [Container{Any}(0)]
    show(io, mime, v)
    show(IOContext(io), mime, v)
    # Object
    v = [Object(0)]
    show(io, mime, v)
    show(IOContext(io), mime, v)
    return nothing
end

precompile(warmup, ())</code></pre><p>We handled not just <code>Vector{Container{Any}}</code> but also <code>Vector{Object}</code>, since that turns out to correspond to the other wide block of red bars. If you make this change, start a fresh session, and recreate the flame graph, you&#39;ll see that the wide red flames are gone:</p><p><img src="../assets/flamegraph-OptimizeMeFixed.png" alt="flamegraph-OptimizeMeFixed"/></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It&#39;s worth noting that this <code>warmup</code> method needed to be carefully written to succeed in its mission. <code>stdout</code> is not inferrable (it&#39;s a global that can be replaced by <code>redirect_stdout</code>), so we needed to annotate its type. We also might have been tempted to use a loop, <code>for io in (stdout, IOContext(stdout)) ... end</code>, but inference needs a dedicated call-site where it knows all the types. (<a href="https://julialang.org/blog/2018/08/union-splitting/">Union-splitting</a> can sometimes come to the rescue, but not if the list is long or elements non-inferrable.) The safest option is to make each call from a separate site in the code.</p></div></div><p>The next trigger, a call to <code>sprint</code> from inside <code>Base.alignment(io::IO, x::Any)</code>, could also be handled using this <code>warmup</code> trick, but the flamegraph says this call (also marked in red) isn&#39;t an expensive method to infer.  In such cases, it&#39;s fine to choose to leave it be.</p><h3 id="Implementing-or-requesting-precompile-directives-in-upstream-packages"><a class="docs-heading-anchor" href="#Implementing-or-requesting-precompile-directives-in-upstream-packages">Implementing or requesting <code>precompile</code> directives in upstream packages</a><a id="Implementing-or-requesting-precompile-directives-in-upstream-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-or-requesting-precompile-directives-in-upstream-packages" title="Permalink"></a></h3><p>Of the remaining triggers (now numbering 14), the flamegraph indicates that the most expensive inference run is</p><pre><code class="nohighlight hljs">Inference triggered to call MethodInstance for show(::IOContext{IOBuffer}, ::Float32) from _show_default (./show.jl:412) with specialization MethodInstance for _show_default(::IOContext{IOBuffer}, ::Any)</code></pre><p>You can check that by listing the children of <code>ROOT</code> in order of <code>inclusive</code> time:</p><pre><code class="language-julia hljs">julia&gt; nodes = sort(tinf.children; by=inclusive)
14-element Vector{SnoopCompileCore.InferenceTimingNode}:
 InferenceTimingNode: 0.000053/0.000053 on InferenceFrameInfo for ==(::Type, nothing::Nothing) with 0 direct children
 InferenceTimingNode: 0.000054/0.000054 on InferenceFrameInfo for sizeof(::Main.OptimizeMeFixed.Container{Any}) with 0 direct children
 InferenceTimingNode: 0.000061/0.000061 on InferenceFrameInfo for Base.typeinfo_eltype(::Type) with 0 direct children
 InferenceTimingNode: 0.000075/0.000380 on InferenceFrameInfo for show(::IOContext{IOBuffer}, ::Any) with 1 direct children
 InferenceTimingNode: 0.000445/0.000445 on InferenceFrameInfo for Pair{Symbol, DataType}(::Any, ::Any) with 0 direct children
 InferenceTimingNode: 0.000663/0.000663 on InferenceFrameInfo for print(::IOContext{Base.TTY}, ::String, ::String, ::Vararg{String, N} where N) with 0 direct children
 InferenceTimingNode: 0.000560/0.001049 on InferenceFrameInfo for Base.var&quot;#sprint#386&quot;(::IOContext{Base.TTY}, ::Int64, sprint::typeof(sprint), ::Function, ::Main.OptimizeMeFixed.Object) with 4 direct children
 InferenceTimingNode: 0.000441/0.001051 on InferenceFrameInfo for Pair(::Symbol, ::Type) with 1 direct children
 InferenceTimingNode: 0.000627/0.001140 on InferenceFrameInfo for Base.var&quot;#sprint#386&quot;(::IOContext{Base.TTY}, ::Int64, sprint::typeof(sprint), ::Function, ::Main.OptimizeMeFixed.Container{Any}) with 4 direct children
 InferenceTimingNode: 0.000321/0.001598 on InferenceFrameInfo for show(::IOContext{IOBuffer}, ::UInt16) with 4 direct children
 InferenceTimingNode: 0.000190/0.012516 on InferenceFrameInfo for show(::IOContext{IOBuffer}, ::Vector{Int64}) with 3 direct children
 InferenceTimingNode: 0.021179/0.033940 on InferenceFrameInfo for Base.Ryu.writeshortest(::Vector{UInt8}, ::Int64, ::Float32, ::Bool, ::Bool, ::Bool, ::Int64, ::UInt8, ::Bool, ::UInt8, ::Bool, ::Bool) with 29 direct children
 InferenceTimingNode: 0.000083/0.035496 on InferenceFrameInfo for show(::IOContext{IOBuffer}, ::Tuple{String, Int64}) with 1 direct children
 InferenceTimingNode: 0.000188/0.092555 on InferenceFrameInfo for show(::IOContext{IOBuffer}, ::Float32) with 1 direct children</code></pre><p>You can see it&#39;s the most expensive remaining root, weighing in at nearly 100ms. This method is defined in the <code>Base.Ryu</code> module,</p><pre><code class="language-julia hljs">julia&gt; node = nodes[end]
InferenceTimingNode: 0.000188/0.092555 on InferenceFrameInfo for show(::IOContext{IOBuffer}, ::Float32) with 1 direct children

julia&gt; Method(node)
show(io::IO, x::T) where T&lt;:Union{Float16, Float32, Float64} in Base.Ryu at ryu/Ryu.jl:111</code></pre><p>Now, we could add this to <code>warmup</code> and at least solve the inference problem. However, on the flamegraph you might note that this is followed shortly by a couple of calls to <code>Ryu.writeshortest</code> (the third-most expensive to infer), followed by a long gap. That hints that other steps, like native code generation, may be expensive. Since these are base Julia methods, and <code>Float32</code> is a common type, it would make sense to file an issue or pull request that Julia should come shipped with these precompiled–that would cache not only the type-inference but also the native code, and thus represents a far more complete solution.</p><p>Later, we&#39;ll see how <code>parcel</code> can generate such precompile directives automatically, so this is not a step you need to implement entirely on your own.</p><p>Another <code>show</code> <code>MethodInstance</code>, <code>show(::IOContext{IOBuffer}, ::Tuple{String, Int64})</code>, seems too specific to be worth worrying about, so we call it quits here.</p><h3 id="ascend-itrig"><a class="docs-heading-anchor" href="#ascend-itrig">Advanced analysis: <code>ascend</code></a><a id="ascend-itrig-1"></a><a class="docs-heading-anchor-permalink" href="#ascend-itrig" title="Permalink"></a></h3><p>One thing that hasn&#39;t yet been covered is that when you really need more insight, you can use <code>ascend</code>:</p><pre><code class="language-julia hljs">julia&gt; itrig = itrigs[5]
Inference triggered to call MethodInstance for show(::IOContext{IOBuffer}, ::Float32) from _show_default (./show.jl:412) with specialization MethodInstance for _show_default(::IOContext{IOBuffer}, ::Any)

julia&gt; ascend(itrig)
Choose a call for analysis (q to quit):
 &gt;   show(::IOContext{IOBuffer}, ::Float32)
       _show_default(::IOContext{IOBuffer}, ::Any) at ./show.jl:412
         show_default at ./show.jl:395 =&gt; show(::IOContext{IOBuffer}, ::Any) at ./show.jl:390
           #sprint#386(::IOContext{Base.TTY}, ::Int64, ::typeof(sprint), ::Function, ::Main.OptimizeMeFixed.Container{Any}) at ./strings/io.jl:103
             sprint##kw at ./strings/io.jl:101 =&gt; alignment at ./show.jl:2528 =&gt; alignment(::IOContext{Base.TTY}, ::Vector{Main.OptimizeMeFixed.Container{Any}}, ::UnitRange{Int64}, ::UnitRange{Int64}, ::
               print_matrix(::IOContext{Base.TTY}, ::AbstractVecOrMat{T} where T, ::String, ::String, ::String, ::String, ::String, ::String, ::Int64, ::Int64) at ./arrayshow.jl:197
                 print_matrix at ./arrayshow.jl:169 =&gt; print_array at ./arrayshow.jl:323 =&gt; show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMeFixed.Container{Any}}) at ./a
                   (::REPL.var&quot;#38#39&quot;{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(&quot;text/plain&quot;)}, Base.RefValue{Any}})(::Any) at /home/tim/src/julia-master/usr/share/julia/stdlib/v1.6/REPL/src/REPL
                     with_repl_linfo(::Any, ::REPL.LineEditREPL) at /home/tim/src/julia-master/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:462
v                      display(::REPL.REPLDisplay, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Any) at /home/tim/src/julia-master/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:213
</code></pre><p><code>ascend</code> was covered in much greater detail in <a href="../snoopr/#invalidations">fixing invalidations</a>, and you can read about using it on that page. Here, one twist is that some lines contain content like</p><pre><code class="nohighlight hljs">show_default at ./show.jl:395 =&gt; show(::IOContext{IOBuffer}, ::Any) at ./show.jl:390</code></pre><p>This indicates that <code>show_default</code> was inlined into <code>show</code>. <code>ascend</code> needs the full non-inlined <code>MethodInstance</code> to descend into, so the tree only includes such nodes. However, within Cthulhu you can toggle optimization and thereby descend into some of these inlined method, or see the full consequence of their inlining into the caller.</p><h2 id="test-suites"><a class="docs-heading-anchor" href="#test-suites">A note on analyzing test suites</a><a id="test-suites-1"></a><a class="docs-heading-anchor-permalink" href="#test-suites" title="Permalink"></a></h2><p>If you&#39;re doing a package analysis, it&#39;s convenient to use the package&#39;s <code>runtests.jl</code> script as a way to cover much of the package&#39;s functionality. SnoopCompile has a couple of enhancements designed to make it easier to ignore inference triggers that come from the test suite itself. First, <code>suggest.(itrigs)</code> may show something like this:</p><pre><code class="nohighlight hljs"> ./broadcast.jl:1315: inlineable (ignore this one)
 ./broadcast.jl:1315: inlineable (ignore this one)
 ./broadcast.jl:1315: inlineable (ignore this one)
 ./broadcast.jl:1315: inlineable (ignore this one)</code></pre><p>This indicates a broadcasting operation in the <code>@testset</code> itself. Second, while it&#39;s a little dangerous (because <code>suggest</code> cannot entirely be trusted), you can filter these out:</p><pre><code class="language-julia hljs">julia&gt; itrigsel = [itrig for itrig in itrigs if !isignorable(suggest(itrig))];

julia&gt; length(itrigs)
222

julia&gt; length(itrigsel)
71</code></pre><p>While there is some risk of discarding triggers that provide clues about the origin of other triggers (e.g., they would have shown up in the same branch of the <code>trigger_tree</code>), the shorter list may help direct your attention to the &quot;real&quot; issues.</p><h2 id="Results-from-the-improvements"><a class="docs-heading-anchor" href="#Results-from-the-improvements">Results from the improvements</a><a id="Results-from-the-improvements-1"></a><a class="docs-heading-anchor-permalink" href="#Results-from-the-improvements" title="Permalink"></a></h2><p>An improved version of <code>OptimizeMe</code> can be found in <code>OptimizeMeFixed.jl</code> in the same directory. Let&#39;s see where we stand:</p><pre><code class="language-julia hljs">julia&gt; tinf = @snoopi_deep OptimizeMeFixed.main()
3.14 is great
2.718 is jealous
...
 Object x: 7
InferenceTimingNode: 0.888522055/1.496965222 on InferenceFrameInfo for Core.Compiler.Timings.ROOT() with 15 direct children</code></pre><p>We&#39;ve substantially shrunk the overall inclusive time from 2.68s to about 1.5s. Some of this came from our single <code>precompile</code> directive, for <code>warmup</code>. But even more of it came from limiting specialization (using <code>Container{Any}</code> instead of <code>Container</code>) and by making some results easier on type-inference (e.g., our changes for the <code>vcat</code> pipeline).</p><p>On the next page, we&#39;ll wrap all this up with more explicit <code>precompile</code> directives.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pgdsgui/">« Profile-guided despecialization</a><a class="docs-footer-nextpage" href="../snoopi_deep_parcel/">Using <code>@snoopi_deep</code> results for precompilation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 21 April 2023 08:52">Friday 21 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
