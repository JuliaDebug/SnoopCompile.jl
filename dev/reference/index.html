<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SnoopCompile</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SnoopCompile</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><a class="tocitem" href="../snoop_pc/">SnoopPrecompile</a></li><li><a class="tocitem" href="../tutorial/">Tutorial on the foundations</a></li><li><span class="tocitem">Modern tools</span><ul><li><a class="tocitem" href="../snoopr/">Snooping on and fixing invalidations: <code>@snoopr</code></a></li><li><a class="tocitem" href="../snoopi_deep/">Snooping on inference: <code>@snoopi_deep</code></a></li><li><a class="tocitem" href="../pgdsgui/">Profile-guided despecialization</a></li><li><a class="tocitem" href="../snoopi_deep_analysis/">Using <code>@snoopi_deep</code> results to improve inferrability</a></li><li><a class="tocitem" href="../snoopi_deep_parcel/">Using <code>@snoopi_deep</code> results for precompilation</a></li><li><a class="tocitem" href="../jet/">JET integration</a></li></ul></li><li><span class="tocitem">Older tools</span><ul><li><a class="tocitem" href="../snoopi/">Snooping on inference: <code>@snoopi</code></a></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li></ul></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Data-collection"><span>Data collection</span></a></li><li><a class="tocitem" href="#GUIs"><span>GUIs</span></a></li><li><a class="tocitem" href="#Analysis-of-invalidations"><span>Analysis of invalidations</span></a></li><li><a class="tocitem" href="#Analysis-of-@snoopi_deep"><span>Analysis of <code>@snoopi_deep</code></span></a></li><li><a class="tocitem" href="#Other-utilities"><span>Other utilities</span></a></li><li><a class="tocitem" href="#Demos"><span>Demos</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Data-collection"><a class="docs-heading-anchor" href="#Data-collection">Data collection</a><a id="Data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Data-collection" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopr" href="#SnoopCompileCore.@snoopr"><code>SnoopCompileCore.@snoopr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">list = @snoopr expr</code></pre><p>Capture method cache invalidations triggered by evaluating <code>expr</code>. <code>list</code> is a sequence of invalidated <code>Core.MethodInstance</code>s together with &quot;explanations,&quot; consisting of integers (encoding depth) and strings (documenting the source of an invalidation).</p><p>Unless you are working at a low level, you essentially always want to pass <code>list</code> directly to <a href="@ref"><code>SnoopCompile.invalidation_trees</code></a>.</p><p><strong>Extended help</strong></p><p><code>list</code> is in a format where the &quot;reason&quot; comes after the items. Method deletion results in the sequence</p><pre><code class="nohighlight hljs">[zero or more (mi, &quot;invalidate_mt_cache&quot;) pairs..., zero or more (depth1 tree, loctag) pairs..., method, loctag] with loctag = &quot;jl_method_table_disable&quot;</code></pre><p>where <code>mi</code> means a <code>MethodInstance</code>. <code>depth1</code> means a sequence starting at <code>depth=1</code>.</p><p>Method insertion results in the sequence</p><pre><code class="nohighlight hljs">[zero or more (depth0 tree, sig) pairs..., same info as with delete_method except loctag = &quot;jl_method_table_insert&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/SnoopCompileCore/src/snoopr.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopi_deep" href="#SnoopCompileCore.@snoopi_deep"><code>SnoopCompileCore.@snoopi_deep</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">tinf = @snoopi_deep commands</code></pre><p>Produce a profile of julia&#39;s type inference, recording the amount of time spent inferring every <code>MethodInstance</code> processed while executing <code>commands</code>. Each fresh entrance to type inference (whether executed directly in <code>commands</code> or because a call was made by runtime-dispatch) also collects a backtrace so the caller can be identified.</p><p><code>tinf</code> is a tree, each node containing data on a particular inference &quot;frame&quot; (the method, argument-type specializations, parameters, and even any constant-propagated values). Each reports the <a href="#SnoopCompileCore.exclusive"><code>exclusive</code></a>/<a href="#SnoopCompileCore.inclusive"><code>inclusive</code></a> times, where the exclusive time corresponds to the time spent inferring this frame in and of itself, whereas the inclusive time includes the time needed to infer all the callees of this frame.</p><p>The top-level node in this profile tree is <code>ROOT</code>. Uniquely, its exclusive time corresponds to the time spent <em>not</em> in julia&#39;s type inference (codegen, llvm_opt, runtime, etc).</p><p>There are many different ways of inspecting and using the data stored in <code>tinf</code>. The simplest is to load the <code>AbstracTrees</code> package and display the tree with <code>AbstractTrees.print_tree(tinf)</code>. See also:  <code>flamegraph</code>, <code>flatten</code>, <code>inference_triggers</code>, <code>SnoopCompile.parcel</code>, <code>runtime_inferencetime</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tinf = @snoopi_deep begin
           sort(rand(100))  # Evaluate some code and profile julia&#39;s type inference
       end
InferenceTimingNode: 0.110018224/0.131464476 on Core.Compiler.Timings.ROOT() with 2 direct children</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/SnoopCompileCore/src/snoopi_deep.jl#L98-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopi" href="#SnoopCompileCore.@snoopi"><code>SnoopCompileCore.@snoopi</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">inf_timing = @snoopi commands
inf_timing = @snoopi tmin=0.0 commands</code></pre><p>Execute <code>commands</code> while snooping on inference. Returns an array of <code>(t, linfo)</code> tuples, where <code>t</code> is the amount of time spent inferring <code>linfo</code> (a <code>MethodInstance</code>).</p><p>Methods that take less time than <code>tmin</code> will not be reported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/SnoopCompileCore/src/snoopi.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopc" href="#SnoopCompileCore.@snoopc"><code>SnoopCompileCore.@snoopc</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@snoopc &quot;compiledata.csv&quot; begin
    # Commands to execute, in a new process
end</code></pre><p>causes the julia compiler to log all functions compiled in the course of executing the commands to the file &quot;compiledata.csv&quot;. This file can be used for the input to <code>SnoopCompile.read</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/SnoopCompileCore/src/snoopc.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.@snoopl" href="#SnoopCompileCore.@snoopl"><code>SnoopCompileCore.@snoopl</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@snoopl &quot;func_names.csv&quot; &quot;llvm_timings.yaml&quot; begin
    # Commands to execute, in a new process
end</code></pre><p>causes the julia compiler to log timing information for LLVM optimization during the provided commands to the files &quot;func<em>names.csv&quot; and &quot;llvm</em>timings.yaml&quot;. These files can be used for the input to <code>SnoopCompile.read_snoopl(&quot;func_names.csv&quot;, &quot;llvm_timings.yaml&quot;)</code>.</p><p>The logs contain the amount of time spent optimizing each &quot;llvm module&quot;, and information about each module, where a module is a collection of functions being optimized together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/SnoopCompileCore/src/snoopl.jl#L5-L17">source</a></section></article><h2 id="GUIs"><a class="docs-heading-anchor" href="#GUIs">GUIs</a><a id="GUIs-1"></a><a class="docs-heading-anchor-permalink" href="#GUIs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.flamegraph" href="#SnoopCompile.flamegraph"><code>SnoopCompile.flamegraph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flamegraph(tinf::InferenceTimingNode; tmin=0.0, excluded_modules=Set([Main]), mode=nothing)</code></pre><p>Convert the call tree of inference timings returned from <code>@snoopi_deep</code> into a FlameGraph. Returns a FlameGraphs.FlameGraph structure that represents the timing trace recorded for type inference.</p><p>Frames that take less than <code>tmin</code> seconds of inclusive time will not be included in the resultant FlameGraph (meaning total time including it and all of its children). This can be helpful if you have a very big profile, to save on processing time.</p><p>Non-precompilable frames are marked in reddish colors. <code>excluded_modules</code> can be used to mark methods defined in modules to which you cannot or do not wish to add precompiles.</p><p><code>mode</code> controls how frames are named in tools like ProfileView. <code>nothing</code> uses the default of just the qualified function name, whereas supplying <code>mode=Dict(method =&gt; count)</code> counting the number of specializations of each method will cause the number of specializations to be included in the frame name.</p><p><strong>Example</strong></p><p>We&#39;ll use <a href="#SnoopCompile.flatten_demo"><code>SnoopCompile.flatten_demo</code></a>, which runs <code>@snoopi_deep</code> on a workload designed to yield reproducible results:</p><pre><code class="language-julia-repl hljs">julia&gt; tinf = SnoopCompile.flatten_demo()
InferenceTimingNode: 0.002148974/0.002767166 on Core.Compiler.Timings.ROOT() with 1 direct children

julia&gt; fg = flamegraph(tinf)
Node(FlameGraphs.NodeData(ROOT() at typeinfer.jl:75, 0x00, 0:3334431))</code></pre><pre><code class="nohighlight hljs">julia&gt; ProfileView.view(fg);  # Display the FlameGraph in a package that supports it</code></pre><p>You should be able to reconcile the resulting flamegraph to <code>print_tree(tinf)</code> (see <a href="#SnoopCompile.flatten"><code>flatten</code></a>).</p><p>The empty horizontal periods in the flamegraph correspond to times when something other than inference is running. The total width of the flamegraph is set from the <code>ROOT</code> node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1748-L1787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.pgdsgui" href="#SnoopCompile.pgdsgui"><code>SnoopCompile.pgdsgui</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">methodref, ax = pgdsgui(tinf::InferenceTimingNode; consts::Bool=true, by=inclusive)
methodref     = pgdsgui(ax, tinf::InferenceTimingNode; kwargs...)</code></pre><p>Create a scatter plot comparing:     - (vertical axis) the inference time for all instances of each Method, as captured by <code>tinf</code>;     - (horizontal axis) the run time cost, as estimated by capturing a <code>@profile</code> before calling this function.</p><p>Each dot corresponds to a single method. The face color encodes the number of times that method was inferred, and the edge color corresponds to the fraction of the runtime spent on runtime dispatch (black is 0%, bright red is 100%). Clicking on a dot prints the method (or location, if inlined) to the REPL, and sets <code>methodref[]</code> to that method.</p><p><code>ax</code> is the pyplot axis of the scatterplot.</p><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p><code>pgdsgui</code> depends on PyPlot via the Requires.jl package. You must load both SnoopCompile and PyPlot for this function to be defined.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/visualizations.jl#L11-L28">source</a></section></article><h2 id="Analysis-of-invalidations"><a class="docs-heading-anchor" href="#Analysis-of-invalidations">Analysis of invalidations</a><a id="Analysis-of-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-invalidations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.uinvalidated" href="#SnoopCompile.uinvalidated"><code>SnoopCompile.uinvalidated</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">umis = uinvalidated(invlist)</code></pre><p>Return the unique invalidated MethodInstances. <code>invlist</code> is obtained from <a href="#SnoopCompileCore.@snoopr"><code>SnoopCompileCore.@snoopr</code></a>. This is similar to <code>filter</code>ing for <code>MethodInstance</code>s in <code>invlist</code>, except that it discards any tagged <code>&quot;invalidate_mt_cache&quot;</code>. These can typically be ignored because they are nearly inconsequential: they do not invalidate any compiled code, they only transiently affect an optimization of runtime dispatch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/invalidations.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.invalidation_trees" href="#SnoopCompile.invalidation_trees"><code>SnoopCompile.invalidation_trees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trees = invalidation_trees(list)</code></pre><p>Parse <code>list</code>, as captured by <a href="#SnoopCompileCore.@snoopr"><code>SnoopCompileCore.@snoopr</code></a>, into a set of invalidation trees, where parents nodes were called by their children.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; f(x::Int)  = 1
f (generic function with 1 method)

julia&gt; f(x::Bool) = 2
f (generic function with 2 methods)

julia&gt; applyf(container) = f(container[1])
applyf (generic function with 1 method)

julia&gt; callapplyf(container) = applyf(container)
callapplyf (generic function with 1 method)

julia&gt; c = Any[1]
1-element Array{Any,1}:
 1

julia&gt; callapplyf(c)
1

julia&gt; trees = invalidation_trees(@snoopr f(::AbstractFloat) = 3)
1-element Array{SnoopCompile.MethodInvalidations,1}:
 inserting f(::AbstractFloat) in Main at REPL[36]:1 invalidated:
   mt_backedges: 1: signature Tuple{typeof(f),Any} triggered MethodInstance for applyf(::Array{Any,1}) (1 children) more specific</code></pre><p>See the documentation for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/invalidations.jl#L324-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.precompile_blockers" href="#SnoopCompile.precompile_blockers"><code>SnoopCompile.precompile_blockers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">staletrees = precompile_blockers(invalidations, tinf::InferenceTimingNode)</code></pre><p>Select just those invalidations that contribute to &quot;stale nodes&quot; in <code>tinf</code>, and link them together. This can allow one to identify specific blockers of precompilation for particular MethodInstances.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using SnoopCompileCore
invalidations = @snoopr using PkgA, PkgB;
using SnoopCompile
trees = invalidation_trees(invalidations)
tinf = @snoopi_deep begin
    some_workload()
end
staletrees = precompile_blockers(trees, tinf)</code></pre><p>In many cases, this reduces the number of invalidations that require analysis by one or more orders of magnitude.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><code>precompile_blockers</code> is experimental and has not yet been thoroughly vetted by real-world use. Users are encouraged to try it and report any &quot;misses&quot; or unnecessary &quot;hits.&quot;</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/invalidation_and_inference.jl#L43-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.filtermod" href="#SnoopCompile.filtermod"><code>SnoopCompile.filtermod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modtrigs = filtermod(mod::Module, mtrigs::AbstractVector{MethodTriggers})</code></pre><p>Select just the method-based triggers arising from a particular module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1086-L1090">source</a></section><section><div><pre><code class="nohighlight hljs">thinned = filtermod(module, trees::AbstractVector{MethodInvalidations}; recursive=false)</code></pre><p>Select just the cases of invalidating a method defined in <code>module</code>.</p><p>If <code>recursive</code> is false, only the roots of trees are examined (i.e., the proximal source of the invalidation must be in <code>module</code>). If <code>recursive</code> is true, then <code>thinned</code> contains all routes to a method in <code>module</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/invalidations.jl#L681-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.findcaller" href="#SnoopCompile.findcaller"><code>SnoopCompile.findcaller</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">methinvs = findcaller(method::Method, trees)</code></pre><p>Find a path through <code>trees</code> that reaches <code>method</code>. Returns a single <code>MethodInvalidations</code> object.</p><p><strong>Examples</strong></p><p>Suppose you know that loading package <code>SomePkg</code> triggers invalidation of <code>f(data)</code>. You can find the specific source of invalidation as follows:</p><pre><code class="nohighlight hljs">f(data)                             # run once to force compilation
m = @which f(data)
using SnoopCompile
trees = invalidation_trees(@snoopr using SomePkg)
methinvs = findcaller(m, trees)</code></pre><p>If you don&#39;t know which method to look for, but know some operation that has had added latency, you can look for methods using <code>@snoopi</code>. For example, suppose that loading <code>SomePkg</code> makes the next <code>using</code> statement slow. You can find the source of trouble with</p><pre><code class="nohighlight hljs">julia&gt; using SnoopCompile

julia&gt; trees = invalidation_trees(@snoopr using SomePkg);

julia&gt; tinf = @snoopi using SomePkg            # this second `using` will need to recompile code invalidated above
1-element Array{Tuple{Float64,Core.MethodInstance},1}:
 (0.08518409729003906, MethodInstance for require(::Module, ::Symbol))

julia&gt; m = tinf[1][2].def
require(into::Module, mod::Symbol) in Base at loading.jl:887

julia&gt; findcaller(m, trees)
inserting ==(x, y::SomeType) in SomeOtherPkg at /path/to/code:100 invalidated:
   backedges: 1: superseding ==(x, y) in Base at operators.jl:83 with MethodInstance for ==(::Symbol, ::Any) (16 children) more specific</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/invalidations.jl#L767-L805">source</a></section></article><h2 id="Analysis-of-@snoopi_deep"><a class="docs-heading-anchor" href="#Analysis-of-@snoopi_deep">Analysis of <code>@snoopi_deep</code></a><a id="Analysis-of-@snoopi_deep-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-@snoopi_deep" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.flatten" href="#SnoopCompile.flatten"><code>SnoopCompile.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatten(tinf; tmin = 0.0, sortby=exclusive)</code></pre><p>Flatten the execution graph of <code>InferenceTimingNode</code>s returned from <code>@snoopi_deep</code> into a Vector of <code>InferenceTiming</code> frames, each encoding the time needed for inference of a single <code>MethodInstance</code>. By default, results are sorted by <code>exclusive</code> time (the time for inferring the <code>MethodInstance</code> itself, not including any inference of its callees); other options are <code>sortedby=inclusive</code> which includes the time needed for the callees, or <code>nothing</code> to obtain them in the order they were inferred (depth-first order).</p><p><strong>Example</strong></p><p>We&#39;ll use <a href="#SnoopCompile.flatten_demo"><code>SnoopCompile.flatten_demo</code></a>, which runs <code>@snoopi_deep</code> on a workload designed to yield reproducible results:</p><pre><code class="language-julia-repl hljs">julia&gt; tinf = SnoopCompile.flatten_demo()
InferenceTimingNode: 0.002148974/0.002767166 on Core.Compiler.Timings.ROOT() with 1 direct children

julia&gt; using AbstractTrees; print_tree(tinf)
InferenceTimingNode: 0.00242354/0.00303526 on Core.Compiler.Timings.ROOT() with 1 direct children
└─ InferenceTimingNode: 0.000150891/0.000611721 on SnoopCompile.FlattenDemo.packintype(::Int64) with 2 direct children
   ├─ InferenceTimingNode: 0.000105318/0.000105318 on SnoopCompile.FlattenDemo.MyType{Int64}(::Int64) with 0 direct children
   └─ InferenceTimingNode: 9.43e-5/0.000355512 on SnoopCompile.FlattenDemo.dostuff(::SnoopCompile.FlattenDemo.MyType{Int64}) with 2 direct children
      ├─ InferenceTimingNode: 6.6458e-5/0.000124716 on SnoopCompile.FlattenDemo.extract(::SnoopCompile.FlattenDemo.MyType{Int64}) with 2 direct children
      │  ├─ InferenceTimingNode: 3.401e-5/3.401e-5 on getproperty(::SnoopCompile.FlattenDemo.MyType{Int64}, ::Symbol) with 0 direct children
      │  └─ InferenceTimingNode: 2.4248e-5/2.4248e-5 on getproperty(::SnoopCompile.FlattenDemo.MyType{Int64}, x::Symbol) with 0 direct children
      └─ InferenceTimingNode: 0.000136496/0.000136496 on SnoopCompile.FlattenDemo.domath(::Int64) with 0 direct children</code></pre><p>Note the printing of <code>getproperty(::SnoopCompile.FlattenDemo.MyType{Int64}, x::Symbol)</code>: it shows the specific Symbol, here <code>:x</code>, that <code>getproperty</code> was inferred with. This reflects constant-propagation in inference.</p><p>Then:</p><pre><code class="language-julia-repl hljs">julia&gt; flatten(tinf; sortby=nothing)
8-element Vector{SnoopCompileCore.InferenceTiming}:
 InferenceTiming: 0.002423543/0.0030352639999999998 on Core.Compiler.Timings.ROOT()
 InferenceTiming: 0.000150891/0.0006117210000000001 on SnoopCompile.FlattenDemo.packintype(::Int64)
 InferenceTiming: 0.000105318/0.000105318 on SnoopCompile.FlattenDemo.MyType{Int64}(::Int64)
 InferenceTiming: 9.43e-5/0.00035551200000000005 on SnoopCompile.FlattenDemo.dostuff(::SnoopCompile.FlattenDemo.MyType{Int64})
 InferenceTiming: 6.6458e-5/0.000124716 on SnoopCompile.FlattenDemo.extract(::SnoopCompile.FlattenDemo.MyType{Int64})
 InferenceTiming: 3.401e-5/3.401e-5 on getproperty(::SnoopCompile.FlattenDemo.MyType{Int64}, ::Symbol)
 InferenceTiming: 2.4248e-5/2.4248e-5 on getproperty(::SnoopCompile.FlattenDemo.MyType{Int64}, x::Symbol)
 InferenceTiming: 0.000136496/0.000136496 on SnoopCompile.FlattenDemo.domath(::Int64)</code></pre><pre><code class="nohighlight hljs">julia&gt; flatten(tinf; tmin=1e-4)                        # sorts by exclusive time (the time before the &#39;/&#39;)
4-element Vector{SnoopCompileCore.InferenceTiming}:
 InferenceTiming: 0.000105318/0.000105318 on SnoopCompile.FlattenDemo.MyType{Int64}(::Int64)
 InferenceTiming: 0.000136496/0.000136496 on SnoopCompile.FlattenDemo.domath(::Int64)
 InferenceTiming: 0.000150891/0.0006117210000000001 on SnoopCompile.FlattenDemo.packintype(::Int64)
 InferenceTiming: 0.002423543/0.0030352639999999998 on Core.Compiler.Timings.ROOT()

julia&gt; flatten(tinf; sortby=inclusive, tmin=1e-4)      # sorts by inclusive time (the time after the &#39;/&#39;)
6-element Vector{SnoopCompileCore.InferenceTiming}:
 InferenceTiming: 0.000105318/0.000105318 on SnoopCompile.FlattenDemo.MyType{Int64}(::Int64)
 InferenceTiming: 6.6458e-5/0.000124716 on SnoopCompile.FlattenDemo.extract(::SnoopCompile.FlattenDemo.MyType{Int64})
 InferenceTiming: 0.000136496/0.000136496 on SnoopCompile.FlattenDemo.domath(::Int64)
 InferenceTiming: 9.43e-5/0.00035551200000000005 on SnoopCompile.FlattenDemo.dostuff(::SnoopCompile.FlattenDemo.MyType{Int64})
 InferenceTiming: 0.000150891/0.0006117210000000001 on SnoopCompile.FlattenDemo.packintype(::Int64)
 InferenceTiming: 0.002423543/0.0030352639999999998 on Core.Compiler.Timings.ROOT()</code></pre><p>As you can see, <code>sortby</code> affects not just the order but also the selection of frames; with exclusive times, <code>dostuff</code> did not on its own rise above threshold, but it does when using inclusive times.</p><p>See also: <a href="#SnoopCompile.accumulate_by_source"><code>accumulate_by_source</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L53-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.exclusive" href="#SnoopCompileCore.exclusive"><code>SnoopCompileCore.exclusive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exclusive(frame)</code></pre><p>Return the time spent inferring <code>frame</code>, not including the time needed for any of its callees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/SnoopCompileCore/src/snoopi_deep.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompileCore.inclusive" href="#SnoopCompileCore.inclusive"><code>SnoopCompileCore.inclusive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inclusive(frame)</code></pre><p>Return the time spent inferring <code>frame</code> and its callees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/SnoopCompileCore/src/snoopi_deep.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.accumulate_by_source" href="#SnoopCompile.accumulate_by_source"><code>SnoopCompile.accumulate_by_source</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accumulate_by_source(flattened; tmin = 0.0, by=exclusive)</code></pre><p>Add the inference timings for all <code>MethodInstance</code>s of a single <code>Method</code> together. <code>flattened</code> is the output of <a href="#SnoopCompile.flatten"><code>flatten</code></a>. Returns a list of <code>(t, method)</code> tuples.</p><p>When the accumulated time for a <code>Method</code> is large, but each instance is small, it indicates that it is being inferred for many specializations (which might include specializations with different constants).</p><p><strong>Example</strong></p><p>We&#39;ll use <a href="#SnoopCompile.flatten_demo"><code>SnoopCompile.flatten_demo</code></a>, which runs <code>@snoopi_deep</code> on a workload designed to yield reproducible results:</p><pre><code class="language-julia-repl hljs">julia&gt; tinf = SnoopCompile.flatten_demo()
InferenceTimingNode: 0.002148974/0.002767166 on Core.Compiler.Timings.ROOT() with 1 direct children

julia&gt; accumulate_by_source(flatten(tinf))
7-element Vector{Tuple{Float64, Union{Method, Core.MethodInstance}}}:
 (6.0012999999999996e-5, getproperty(x, f::Symbol) in Base at Base.jl:33)
 (6.7714e-5, extract(y::SnoopCompile.FlattenDemo.MyType) in SnoopCompile.FlattenDemo at /pathto/SnoopCompile/src/deep_demos.jl:35)
 (9.421e-5, dostuff(y) in SnoopCompile.FlattenDemo at /pathto/SnoopCompile/src/deep_demos.jl:44)
 (0.000112057, SnoopCompile.FlattenDemo.MyType{T}(x) where T in SnoopCompile.FlattenDemo at /pathto/SnoopCompile/src/deep_demos.jl:34)
 (0.000133895, domath(x) in SnoopCompile.FlattenDemo at /pathto/SnoopCompile/src/deep_demos.jl:40)
 (0.000154382, packintype(x) in SnoopCompile.FlattenDemo at /pathto/SnoopCompile/src/deep_demos.jl:36)
 (0.003165266, ROOT() in Core.Compiler.Timings at compiler/typeinfer.jl:75)</code></pre><p>Compared to the output from <a href="#SnoopCompile.flatten"><code>flatten</code></a>, the two inferences passes on <code>getproperty</code> have been consolidated into a single aggregate call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L138-L168">source</a></section><section><div><pre><code class="nohighlight hljs">mtrigs = accumulate_by_source(Method, itrigs::AbstractVector{InferenceTrigger})</code></pre><p>Consolidate inference triggers via their caller method. <code>mtrigs</code> is a vector of <code>Method=&gt;list</code> pairs, where <code>list</code> is a list of <code>InferenceTrigger</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1061-L1066">source</a></section><section><div><pre><code class="nohighlight hljs">loctrigs = accumulate_by_source(itrigs::AbstractVector{InferenceTrigger})</code></pre><p>Aggregate inference triggers by location (function, file, and line number) of the caller.</p><p><strong>Example</strong></p><p>We collect data using the <a href="#SnoopCompile.itrigs_demo"><code>SnoopCompile.itrigs_demo</code></a>:</p><pre><code class="language-julia hljs">julia&gt; itrigs = inference_triggers(SnoopCompile.itrigs_demo())
2-element Vector{InferenceTrigger}:
 Inference triggered to call MethodInstance for double(::UInt8) from calldouble1 (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:762) inlined into MethodInstance for calldouble2(::Vector{Vector{Any}}) (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:763)
 Inference triggered to call MethodInstance for double(::Float64) from calldouble1 (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:762) inlined into MethodInstance for calldouble2(::Vector{Vector{Any}}) (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:763)

julia&gt; accumulate_by_source(itrigs)
1-element Vector{SnoopCompile.LocationTriggers}:
    calldouble1 at /pathto/SnoopCompile/src/parcel_snoopi_deep.jl:762 (2 callees from 1 callers)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1139-L1158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.collect_for" href="#SnoopCompile.collect_for"><code>SnoopCompile.collect_for</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">list = collect_for(m::Method, tinf::InferenceTimingNode)
list = collect_for(m::MethodInstance, tinf::InferenceTimingNode)</code></pre><p>Collect all <code>InferenceTimingNode</code>s (descendants of <code>tinf</code>) that match <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.staleinstances" href="#SnoopCompile.staleinstances"><code>SnoopCompile.staleinstances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">staleinstances(tinf::InferenceTimingNode)</code></pre><p>Return a list of <code>InferenceTimingNode</code>s corresponding to <code>MethodInstance</code>s that have &quot;stale&quot; code (specifically, <code>CodeInstance</code>s with outdated <code>max_world</code> world ages). These may be a hint that invalidation occurred while running the workload provided to <code>@snoopi_deep</code>, and consequently an important origin of (re)inference.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>staleinstances</code> only looks <em>retrospectively</em> for stale code; it does not distinguish whether the code became stale while running <code>@snoopi_deep</code> from whether it was already stale before execution commenced.</p></div></div><p>While <code>staleinstances</code> is recommended as a useful &quot;sanity check&quot; to run before performing a detailed analysis of inference, any serious examination of invalidation should use <a href="#SnoopCompileCore.@snoopr"><code>@snoopr</code></a>.</p><p>For more information about world age, see https://docs.julialang.org/en/v1/manual/methods/#Redefining-Methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L203-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.inference_triggers" href="#SnoopCompile.inference_triggers"><code>SnoopCompile.inference_triggers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">itrigs = inference_triggers(tinf::InferenceTimingNode; exclude_toplevel=true)</code></pre><p>Collect the &quot;triggers&quot; of inference, each a fresh entry into inference via a call dispatched at runtime. All the entries in <code>itrigs</code> are previously uninferred, or are freshly-inferred for specific constant inputs.</p><p><code>exclude_toplevel</code> determines whether calls made from the REPL, <code>include</code>, or test suites are excluded.</p><p><strong>Example</strong></p><p>We&#39;ll use <a href="#SnoopCompile.itrigs_demo"><code>SnoopCompile.itrigs_demo</code></a>, which runs <code>@snoopi_deep</code> on a workload designed to yield reproducible results:</p><pre><code class="language-julia-repl hljs">julia&gt; tinf = SnoopCompile.itrigs_demo()
InferenceTimingNode: 0.004490576/0.004711168 on Core.Compiler.Timings.ROOT() with 2 direct children

julia&gt; itrigs = inference_triggers(tinf)
2-element Vector{InferenceTrigger}:
 Inference triggered to call MethodInstance for double(::UInt8) from calldouble1 (/pathto/SnoopCompile/src/deep_demos.jl:86) inlined into MethodInstance for calldouble2(::Vector{Vector{Any}}) (/pathto/SnoopCompile/src/deep_demos.jl:87)
 Inference triggered to call MethodInstance for double(::Float64) from calldouble1 (/pathto/SnoopCompile/src/deep_demos.jl:86) inlined into MethodInstance for calldouble2(::Vector{Vector{Any}}) (/pathto/SnoopCompile/src/deep_demos.jl:87)</code></pre><pre><code class="nohighlight hljs">julia&gt; edit(itrigs[1])     # opens an editor at the spot in the caller

julia&gt; ascend(itrigs[2])   # use Cthulhu to inspect the stacktrace (caller is the second item in the trace)
Choose a call for analysis (q to quit):
 &gt;   double(::Float64)
       calldouble1 at /pathto/SnoopCompile/src/deep_demos.jl:86 =&gt; calldouble2(::Vector{Vector{Any}}) at /pathto/SnoopCompile/src/deep_demos.jl:87
         calleach(::Vector{Vector{Vector{Any}}}) at /pathto/SnoopCompile/src/deep_demos.jl:88
...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L695-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.trigger_tree" href="#SnoopCompile.trigger_tree"><code>SnoopCompile.trigger_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">root = trigger_tree(itrigs)</code></pre><p>Organize inference triggers <code>itrigs</code> in tree format, grouping items via the call tree.</p><p>It is a tree rather than a more general graph due to the fact that caching inference results means that each node gets visited only once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1018-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.suggest" href="#SnoopCompile.suggest"><code>SnoopCompile.suggest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">suggest(itrig::InferenceTrigger)</code></pre><p>Analyze <code>itrig</code> and attempt to suggest an interpretation or remedy. This returns a structure of type <code>Suggested</code>; the easiest thing to do with the result is to <code>show</code> it; however, you can also filter a list of suggestions.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; itrigs = inference_triggers(tinf);

julia&gt; sugs = suggest.(itrigs);

julia&gt; sugs_important = filter(!isignorable, sugs)    # discard the ones that probably don&#39;t need to be addressed</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Suggestions are approximate at best; most often, the proposed fixes should not be taken literally, but instead taken as a hint about the &quot;outcome&quot; of a particular runtime dispatch incident. The suggestions target calls made with non-inferrable argumets, but often the best place to fix the problem is at an earlier stage in the code, where the argument was first computed.</p><p>You can get much deeper insight via <code>ascend</code> (and Cthulhu generally), and even <code>stacktrace</code> is often useful. Suggestions are intended to be a quick and easier-to-comprehend first pass at analyzing an inference trigger.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1393-L1417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.isignorable" href="#SnoopCompile.isignorable"><code>SnoopCompile.isignorable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isignorable(s::Suggested)</code></pre><p>Returns <code>true</code> if <code>s</code> is unlikely to be an inference problem in need of fixing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1378-L1382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.callerinstance" href="#SnoopCompile.callerinstance"><code>SnoopCompile.callerinstance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mi = callerinstance(itrig::InferenceTrigger)</code></pre><p>Return the MethodInstance <code>mi</code> of the caller in the selected stackframe in <code>itrig</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L645-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.callingframe" href="#SnoopCompile.callingframe"><code>SnoopCompile.callingframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">itrigcaller = callingframe(itrig::InferenceTrigger)</code></pre><p>&quot;Step out&quot; one layer of the stacktrace, referencing the caller of the current frame of <code>itrig</code>.</p><p>You can retrieve the proximal trigger of inference with <code>InferenceTrigger(itrigcaller)</code>.</p><p><strong>Example</strong></p><p>We collect data using the <a href="#SnoopCompile.itrigs_demo"><code>SnoopCompile.itrigs_demo</code></a>:</p><pre><code class="language-julia hljs">julia&gt; itrig = inference_triggers(SnoopCompile.itrigs_demo())[1]
Inference triggered to call MethodInstance for double(::UInt8) from calldouble1 (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:762) inlined into MethodInstance for calldouble2(::Vector{Vector{Any}}) (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:763)

julia&gt; itrigcaller = callingframe(itrig)
Inference triggered to call MethodInstance for double(::UInt8) from calleach (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:764) with specialization MethodInstance for calleach(::Vector{Vector{Vector{Any}}})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L769-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.skiphigherorder" href="#SnoopCompile.skiphigherorder"><code>SnoopCompile.skiphigherorder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">itrignew = skiphigherorder(itrig; exact::Bool=false)</code></pre><p>Attempt to skip over frames of higher-order functions that take the callee as a function-argument. This can be useful if you&#39;re analyzing inference triggers for an entire package and would prefer to assign triggers to package-code rather than Base functions like <code>map!</code>, <code>broadcast</code>, etc.</p><p><strong>Example</strong></p><p>We collect data using the <a href="#SnoopCompile.itrigs_higherorder_demo"><code>SnoopCompile.itrigs_higherorder_demo</code></a>:</p><pre><code class="language-julia hljs">julia&gt; itrig = inference_triggers(SnoopCompile.itrigs_higherorder_demo())[1]
Inference triggered to call MethodInstance for double(::Float64) from mymap! (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:706) with specialization MethodInstance for mymap!(::typeof(SnoopCompile.ItrigHigherOrderDemo.double), ::Vector{Any}, ::Vector{Any})

julia&gt; callingframe(itrig)      # step out one (non-inlined) frame
Inference triggered to call MethodInstance for double(::Float64) from mymap (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:710) with specialization MethodInstance for mymap(::typeof(SnoopCompile.ItrigHigherOrderDemo.double), ::Vector{Any})

julia&gt; skiphigherorder(itrig)   # step out to frame that doesn&#39;t have `double` as a function-argument
Inference triggered to call MethodInstance for double(::Float64) from callmymap (/pathto/SnoopCompile/src/parcel_snoopi_deep.jl:711) with specialization MethodInstance for callmymap(::Vector{Any})</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>By default <code>skiphigherorder</code> is conservative, and insists on being sure that it&#39;s the callee being passed to the higher-order function. Higher-order functions that do not get specialized (e.g., with <code>::Function</code> argument types) will not be skipped over. You can pass <code>exact=false</code> to allow <code>::Function</code> to also be passed over, but keep in mind that this may falsely skip some frames.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L808-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.InferenceTrigger" href="#SnoopCompile.InferenceTrigger"><code>SnoopCompile.InferenceTrigger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InferenceTrigger(callee::MethodInstance, callerframes::Vector{StackFrame}, btidx::Int, bt)</code></pre><p>Organize information about the &quot;triggers&quot; of inference. <code>callee</code> is the <code>MethodInstance</code> requiring inference, <code>callerframes</code>, <code>btidx</code> and <code>bt</code> contain information about the caller. <code>callerframes</code> are the frame(s) of call site that triggered inference; it&#39;s a <code>Vector{StackFrame}</code>, rather than a single <code>StackFrame</code>, due to the possibility that the caller was inlined into something else, in which case the first entry is the direct caller and the last entry corresponds to the MethodInstance into which it was ultimately inlined. <code>btidx</code> is the index in <code>bt</code>, the backtrace collected upon entry into inference, corresponding to <code>callerframes</code>.</p><p><code>InferenceTrigger</code>s are created by calling <a href="#SnoopCompile.inference_triggers"><code>inference_triggers</code></a>. See also: <a href="#SnoopCompile.callerinstance"><code>callerinstance</code></a> and <a href="#SnoopCompile.callingframe"><code>callingframe</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L602-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.runtime_inferencetime" href="#SnoopCompile.runtime_inferencetime"><code>SnoopCompile.runtime_inferencetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ridata = runtime_inferencetime(tinf::InferenceTimingNode; consts=true, by=inclusive)
ridata = runtime_inferencetime(tinf::InferenceTimingNode, profiledata; lidict, consts=true, by=inclusive)</code></pre><p>Compare runtime and inference-time on a per-method basis. <code>ridata[m::Method]</code> returns <code>(trun, tinfer, nspecializations)</code>, measuring the approximate amount of time spent running <code>m</code>, inferring <code>m</code>, and the number of type-specializations, respectively. <code>trun</code> is estimated from profiling data, which the user is responsible for capturing before the call. Typically <code>tinf</code> is collected via <code>@snoopi_deep</code> on the first call (in a fresh session) to a workload, and the profiling data collected on a subsequent call. In some cases you may need to repeat the workload several times to collect enough profiling samples.</p><p><code>profiledata</code> and <code>lidict</code> are obtained from <code>Profile.retrieve()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L460-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.parcel" href="#SnoopCompile.parcel"><code>SnoopCompile.parcel</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>pc = parcel(calls; subst=[], exclusions=[])</code> assigns each compile statement to the module that owns the function. Perform string substitution via <code>subst=[&quot;Module1&quot;=&gt;&quot;Module2&quot;]</code>, and omit functions in particular modules with <code>exclusions=[&quot;Module3&quot;]</code>. On output, <code>pc[:Module2]</code> contains all the precompiles assigned to <code>Module2</code>.</p><p>Use <code>SnoopCompile.write(prefix, pc)</code> to generate a series of files in directory <code>prefix</code>, one file per module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopc.jl#L126-L130">source</a></section><section><div><pre><code class="nohighlight hljs">ttot, pcs = SnoopCompile.parcel(tinf::InferenceTimingNode)</code></pre><p>Parcel the &quot;root-most&quot; precompilable MethodInstances into separate modules. These can be used to generate <code>precompile</code> directives to cache the results of type-inference, reducing latency on first use.</p><p>Loosely speaking, and MethodInstance is precompilable if the module that owns the method also has access to all the types it need to precompile the instance. When the root node of an entrance to inference is not itself precompilable, <code>parcel</code> examines the children (and possibly, children&#39;s children...) until it finds the first node on each branch that is precompilable. <code>MethodInstances</code> are then assigned to the module that owns the method.</p><p><code>ttot</code> is the total inference time; <code>pcs</code> is a list of <code>module =&gt; (tmod, pclist)</code> pairs. For each module, <code>tmod</code> is the amount of inference time affiliated with methods owned by that module; <code>pclist</code> is a list of <code>(t, mi)</code> time/MethodInstance tuples.</p><p>See also: <a href="#SnoopCompile.write"><code>SnoopCompile.write</code></a>.</p><p><strong>Example</strong></p><p>We&#39;ll use <a href="#SnoopCompile.itrigs_demo"><code>SnoopCompile.itrigs_demo</code></a>, which runs <code>@snoopi_deep</code> on a workload designed to yield reproducible results:</p><pre><code class="language-julia-repl hljs">julia&gt; tinf = SnoopCompile.itrigs_demo()
InferenceTimingNode: 0.004490576/0.004711168 on Core.Compiler.Timings.ROOT() with 2 direct children

julia&gt; ttot, pcs = SnoopCompile.parcel(tinf);

julia&gt; ttot
0.000220592

julia&gt; pcs
1-element Vector{Pair{Module, Tuple{Float64, Vector{Tuple{Float64, Core.MethodInstance}}}}}:
 SnoopCompile.ItrigDemo =&gt; (0.000220592, [(9.8986e-5, MethodInstance for double(::Float64)), (0.000121606, MethodInstance for double(::UInt8))])</code></pre><p>Since there was only one module, <code>ttot</code> is the same as <code>tmod</code>. The <code>ItrigDemo</code> module had two precomilable MethodInstances, each listed with its corresponding inclusive time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L339-L378">source</a></section><section><div><pre><code class="nohighlight hljs">modtrigs = SnoopCompile.parcel(mtrigs::AbstractVector{MethodTriggers})</code></pre><p>Split method-based triggers into collections organized by the module in which the methods were defined. Returns a <code>module =&gt; list</code> vector, with the module having the most <code>MethodTriggers</code> last.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L1093-L1098">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.write" href="#SnoopCompile.write"><code>SnoopCompile.write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write(prefix::AbstractString, pc::Dict; always::Bool = false)</code></pre><p>Write each modules&#39; precompiles to a separate file.  If <code>always</code> is true, the generated function will always run the precompile statements when called, otherwise the statements will only be called during package precompilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/write.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.report_callee" href="#SnoopCompile.report_callee"><code>SnoopCompile.report_callee</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_callee(itrig::InferenceTrigger)</code></pre><p>Return the <code>JET.report_call</code> for the callee in <code>itrig</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L900-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.report_callees" href="#SnoopCompile.report_callees"><code>SnoopCompile.report_callees</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_callees(itrigs)</code></pre><p>Filter <code>itrigs</code> for those with a non-passing <code>JET</code> report, returning the list of <code>itrig =&gt; report</code> pairs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fib(n::Integer) = n ≤ 2 ? n : fib(n-1) + fib(n-2);

julia&gt; function fib(str::String)
           n = length(str)
           return fib(m)    # error is here
       end
fib (generic function with 2 methods)

julia&gt; fib(::Dict) = 0; fib(::Vector) = 0;

julia&gt; list = [5, &quot;hello&quot;];

julia&gt; mapfib(list) = map(fib, list)
mapfib (generic function with 1 method)

julia&gt; tinf = @snoopi_deep try mapfib(list) catch end
InferenceTimingNode: 0.049825/0.071476 on Core.Compiler.Timings.ROOT() with 5 direct children

julia&gt; @report_call mapfib(list)
No errors detected</code></pre><p>JET did not catch the error because the call to <code>fib</code> is hidden behind runtime dispatch. However, when captured by <code>@snoopi_deep</code>, we get</p><pre><code class="language-julia-repl hljs">julia&gt; report_callees(inference_triggers(tinf))
1-element Vector{Pair{InferenceTrigger, JET.JETCallResult{JET.JETAnalyzer{JET.BasicPass{typeof(JET.basic_function_filter)}}, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}}}:
 Inference triggered to call fib(::String) from iterate (./generator.jl:47) inlined into Base.collect_to!(::Vector{Int64}, ::Base.Generator{Vector{Any}, typeof(fib)}, ::Int64, ::Int64) (./array.jl:782) =&gt; ═════ 1 possible error found ═════
┌ @ none:3 fib(m)
│ variable `m` is not defined
└──────────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L914-L955">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.report_caller" href="#SnoopCompile.report_caller"><code>SnoopCompile.report_caller</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">report_caller(itrig::InferenceTrigger)</code></pre><p>Return the <code>JET.report_call</code> for the caller in <code>itrig</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopi_deep.jl#L907-L911">source</a></section></article><h2 id="Other-utilities"><a class="docs-heading-anchor" href="#Other-utilities">Other utilities</a><a id="Other-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Other-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.read" href="#SnoopCompile.read"><code>SnoopCompile.read</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>SnoopCompile.read(&quot;compiledata.csv&quot;)</code> reads the log file produced by the compiler and returns the functions as a pair of arrays. The first array is the amount of time required to compile each function, the second is the corresponding function + types. The functions are sorted in order of increasing compilation time. (The time does not include the cost of nested compiles.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopc.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.read_snoopl" href="#SnoopCompile.read_snoopl"><code>SnoopCompile.read_snoopl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">times, info = SnoopCompile.read_snoopl(&quot;func_names.csv&quot;, &quot;llvm_timings.yaml&quot;; tmin_secs=0.0)</code></pre><p>Reads the log file produced by the compiler and returns the structured representations.</p><p>The results will only contain modules that took longer than <code>tmin_secs</code> to optimize.</p><p><strong>Return value</strong></p><ul><li><code>times</code> contains the time spent optimizing each module, as a Pair from the time to an</li></ul><p>array of Strings, one for every MethodInstance in that llvm module.</p><ul><li><code>info</code> is a Dict containing statistics for each MethodInstance encountered, from before</li></ul><p>and after optimization, including number of instructions and number of basicblocks.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; @snoopl &quot;func_names.csv&quot; &quot;llvm_timings.yaml&quot; begin
           using InteractiveUtils
           @eval InteractiveUtils.peakflops()
       end
Launching new julia process to run commands...
done.

julia&gt; times, info = SnoopCompile.read_snoopl(&quot;func_names.csv&quot;, &quot;llvm_timings.yaml&quot;, tmin_secs = 0.025);

julia&gt; times
3-element Vector{Pair{Float64, Vector{String}}}:
 0.028170923 =&gt; [&quot;Tuple{typeof(LinearAlgebra.copy_transpose!), Array{Float64, 2}, Base.UnitRange{Int64}, Base.UnitRange{Int64}, Array{Float64, 2}, Base.UnitRange{Int64}, Base.UnitRange{Int64}}&quot;]
 0.031356962 =&gt; [&quot;Tuple{typeof(Base.copyto!), Array{Float64, 2}, Base.UnitRange{Int64}, Base.UnitRange{Int64}, Array{Float64, 2}, Base.UnitRange{Int64}, Base.UnitRange{Int64}}&quot;]
 0.149138788 =&gt; [&quot;Tuple{typeof(LinearAlgebra._generic_matmatmul!), Array{Float64, 2}, Char, Char, Array{Float64, 2}, Array{Float64, 2}, LinearAlgebra.MulAddMul{true, true, Bool, Bool}}&quot;]

julia&gt; info
Dict{String, NamedTuple{(:before, :after), Tuple{NamedTuple{(:instructions, :basicblocks), Tuple{Int64, Int64}}, NamedTuple{(:instructions, :basicblocks), Tuple{Int64, Int64}}}}} with 3 entries:
  &quot;Tuple{typeof(LinearAlgebra.copy_transpose!), Ar… =&gt; (before = (instructions = 651, basicblocks = 83), after = (instructions = 348, basicblocks = 40…
  &quot;Tuple{typeof(Base.copyto!), Array{Float64, 2}, … =&gt; (before = (instructions = 617, basicblocks = 77), after = (instructions = 397, basicblocks = 37…
  &quot;Tuple{typeof(LinearAlgebra._generic_matmatmul!)… =&gt; (before = (instructions = 4796, basicblocks = 824), after = (instructions = 1421, basicblocks =…</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopl.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.format_userimg" href="#SnoopCompile.format_userimg"><code>SnoopCompile.format_userimg</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>pc = format_userimg(calls; subst=[], exclusions=[])</code> generates precompile directives intended for your base/userimg.jl script. Use <code>SnoopCompile.write(filename, pc)</code> to create a file that you can <code>include</code> into <code>userimg.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/parcel_snoopc.jl#L178-L180">source</a></section></article><h2 id="Demos"><a class="docs-heading-anchor" href="#Demos">Demos</a><a id="Demos-1"></a><a class="docs-heading-anchor-permalink" href="#Demos" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.flatten_demo" href="#SnoopCompile.flatten_demo"><code>SnoopCompile.flatten_demo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tinf = SnoopCompile.flatten_demo()</code></pre><p>A simple demonstration of <a href="#SnoopCompileCore.@snoopi_deep"><code>@snoopi_deep</code></a>. This demo defines a module</p><pre><code class="language-julia hljs">module FlattenDemo
    struct MyType{T} x::T end
    extract(y::MyType) = y.x
    function packintype(x)
        y = MyType{Int}(x)
        return dostuff(y)
    end
    function domath(x)
        y = x + x
        return y*x + 2*x + 5
    end
    dostuff(y) = domath(extract(y))
end</code></pre><p>It then &quot;warms up&quot; (forces inference on) all of Julia&#39;s <code>Base</code> methods needed for <code>domath</code>, to ensure that these MethodInstances do not need to be inferred when we collect the data. It then returns the results of</p><pre><code class="language-julia hljs">@snoopi_deep FlattenDemo.packintypes(1)</code></pre><p>See <a href="#SnoopCompile.flatten"><code>flatten</code></a> for an example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/deep_demos.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.itrigs_demo" href="#SnoopCompile.itrigs_demo"><code>SnoopCompile.itrigs_demo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tinf = SnoopCompile.itrigs_demo()</code></pre><p>A simple demonstration of collecting inference triggers. This demo defines a module</p><pre><code class="language-julia hljs">module ItrigDemo
@noinline double(x) = 2x
@inline calldouble1(c) = double(c[1])
calldouble2(cc) = calldouble1(cc[1])
calleach(ccs) = (calldouble2(ccs[1]), calldouble2(ccs[2]))
end</code></pre><p>It then &quot;warms up&quot; (forces inference on) <code>calldouble2(::Vector{Vector{Any}})</code>, <code>calldouble1(::Vector{Any})</code>, <code>double(::Int)</code>:</p><pre><code class="language-julia hljs">cc = [Any[1]]
ItrigDemo.calleach([cc,cc])</code></pre><p>Then it collects and returns inference data using</p><pre><code class="language-julia hljs">cc1, cc2 = [Any[0x01]], [Any[1.0]]
@snoopi_deep ItrigDemo.calleach([cc1, cc2])</code></pre><p>This does not require any new inference for <code>calldouble2</code> or <code>calldouble1</code>, but it does force inference on <code>double</code> with two new types. See <a href="#SnoopCompile.inference_triggers"><code>inference_triggers</code></a> to see what gets collected and returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/deep_demos.jl#L52-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SnoopCompile.itrigs_higherorder_demo" href="#SnoopCompile.itrigs_higherorder_demo"><code>SnoopCompile.itrigs_higherorder_demo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tinf = SnoopCompile.itrigs_higherorder_demo()</code></pre><p>A simple demonstration of handling higher-order methods with inference triggers. This demo defines a module</p><pre><code class="language-julia hljs">module ItrigHigherOrderDemo
double(x) = 2x
@noinline function mymap!(f, dst, src)
    for i in eachindex(dst, src)
        dst[i] = f(src[i])
    end
    return dst
end
@noinline mymap(f::F, src) where F = mymap!(f, Vector{Any}(undef, length(src)), src)
callmymap(src) = mymap(double, src)
end</code></pre><p>The key feature of this set of definitions is that the function <code>double</code> gets passed as an argument through <code>mymap</code> and <code>mymap!</code> (the latter are <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a>).</p><p>It then &quot;warms up&quot; (forces inference on) <code>callmymap(::Vector{Any})</code>, <code>mymap(::typeof(double), ::Vector{Any})</code>, <code>mymap!(::typeof(double), ::Vector{Any}, ::Vector{Any})</code> and <code>double(::Int)</code>:</p><pre><code class="language-julia hljs">ItrigHigherOrderDemo.callmymap(Any[1, 2])</code></pre><p>Then it collects and returns inference data using</p><pre><code class="language-julia hljs">@snoopi_deep ItrigHigherOrderDemo.callmymap(Any[1.0, 2.0])</code></pre><p>which forces inference for <code>double(::Float64)</code>.</p><p>See <a href="#SnoopCompile.skiphigherorder"><code>skiphigherorder</code></a> for an example using this demo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/SnoopCompile.jl/blob/0d84aed1c40c670806768b3d53004e5bb397ba62/src/deep_demos.jl#L100-L138">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../userimg/">« Creating <code>userimg.jl</code> files</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 21 April 2023 08:52">Friday 21 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
