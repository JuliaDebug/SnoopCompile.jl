<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Snooping on inference: @snoopi_deep · SnoopCompile</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SnoopCompile</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><a class="tocitem" href="../snoop_pc/">SnoopPrecompile</a></li><li><a class="tocitem" href="../tutorial/">Tutorial on the foundations</a></li><li><span class="tocitem">Modern tools</span><ul><li><a class="tocitem" href="../snoopr/">Snooping on and fixing invalidations: <code>@snoopr</code></a></li><li class="is-active"><a class="tocitem" href>Snooping on inference: <code>@snoopi_deep</code></a><ul class="internal"><li><a class="tocitem" href="#Collecting-the-data"><span>Collecting the data</span></a></li><li><a class="tocitem" href="#A-quick-check-for-potential-invalidations"><span>A quick check for potential invalidations</span></a></li><li><a class="tocitem" href="#Viewing-the-results"><span>Viewing the results</span></a></li></ul></li><li><a class="tocitem" href="../pgdsgui/">Profile-guided despecialization</a></li><li><a class="tocitem" href="../snoopi_deep_analysis/">Using <code>@snoopi_deep</code> results to improve inferrability</a></li><li><a class="tocitem" href="../snoopi_deep_parcel/">Using <code>@snoopi_deep</code> results for precompilation</a></li><li><a class="tocitem" href="../jet/">JET integration</a></li></ul></li><li><span class="tocitem">Older tools</span><ul><li><a class="tocitem" href="../snoopi/">Snooping on inference: <code>@snoopi</code></a></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li></ul></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modern tools</a></li><li class="is-active"><a href>Snooping on inference: <code>@snoopi_deep</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Snooping on inference: <code>@snoopi_deep</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/snoopi_deep.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Snooping-on-inference:-@snoopi_deep"><a class="docs-heading-anchor" href="#Snooping-on-inference:-@snoopi_deep">Snooping on inference: <code>@snoopi_deep</code></a><a id="Snooping-on-inference:-@snoopi_deep-1"></a><a class="docs-heading-anchor-permalink" href="#Snooping-on-inference:-@snoopi_deep" title="Permalink"></a></h1><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p><code>@snoopi_deep</code> is available on <code>Julia 1.6.0-DEV.1190</code> or above, but the results can be relevant for all Julia versions.</p></div></div><p>Currently, <code>precompile</code> only caches results for type-inference, not other stages in code generation. For that reason, efforts at reducing latency should be informed by measuring the amount of time spent on type-inference. Moreover, because all code needs to be type-inferred before undergoing later stages of code generation, monitoring this &quot;entry point&quot; can give you an overview of the entire compile chain.</p><p>On older versions of Julia, <a href="../reference/#SnoopCompileCore.@snoopi"><code>@snoopi</code></a> allows you to make fairly coarse measurements on inference; starting with Julia 1.6, the recommended tool is <a href="../reference/#SnoopCompileCore.@snoopi_deep"><code>@snoopi_deep</code></a>, which collects a much more detailed picture of type-inference&#39;s actions.</p><p>The rich data collected by <code>@snoopi_deep</code> are useful for several different purposes; on this page, we&#39;ll describe the basic tool and show how it can be used to profile inference. On later pages we&#39;ll show other ways to use the data to reduce the amount of type-inference or cache its results.</p><h2 id="Collecting-the-data"><a class="docs-heading-anchor" href="#Collecting-the-data">Collecting the data</a><a id="Collecting-the-data-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-the-data" title="Permalink"></a></h2><p>Like <a href="../reference/#SnoopCompileCore.@snoopr"><code>@snoopr</code></a>, <code>@snoopi_deep</code> is exported by both <code>SnoopCompileCore</code> and <code>SnoopCompile</code>, but in this case there is not as much reason to do the data collection by a very minimal package.  Consequently here we&#39;ll just load <code>SnoopCompile</code> at the outset.</p><p>To see <code>@snoopi_deep</code> in action, we&#39;ll use the following demo:</p><pre><code class="language-julia hljs">module FlattenDemo
    struct MyType{T} x::T end

    extract(y::MyType) = y.x

    function domath(x)
        y = x + x
        return y*x + 2*x + 5
    end

    dostuff(y) = domath(extract(y))

    function packintype(x)
        y = MyType{Int}(x)
        return dostuff(y)
    end
end

# output

FlattenDemo</code></pre><p>The main call, <code>packintype</code>, stores the input in a <code>struct</code>, and then calls functions that extract the field value and performs arithmetic on the result. To profile inference on this call, we simply do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; tinf = @snoopi_deep FlattenDemo.packintype(1)
InferenceTimingNode: 0.002712/0.003278 on Core.Compiler.Timings.ROOT() with 1 direct children</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Inference gets called only on the <em>first</em> invocation of a method with those specific types. You have to redefine the <code>FlattenDemo</code> module (by just re-executing the command we used to define it) if you want to collect data with <code>@snoopi_deep</code> on the same code a second time.</p><p>To make it easier to perform these demonstrations and use them for documentation purposes, <code>SnoopCompile</code> includes a function <a href="../reference/#SnoopCompile.flatten_demo"><code>SnoopCompile.flatten_demo()</code></a> that redefines the module and returns <code>tinf</code>.</p></div></div><p>This may not look like much, but there&#39;s a wealth of information hidden inside <code>tinf</code>.</p><h2 id="A-quick-check-for-potential-invalidations"><a class="docs-heading-anchor" href="#A-quick-check-for-potential-invalidations">A quick check for potential invalidations</a><a id="A-quick-check-for-potential-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#A-quick-check-for-potential-invalidations" title="Permalink"></a></h2><p>After running <code>@snoopi_deep</code>, it&#39;s generally recommended to check the output of <a href="../reference/#SnoopCompile.staleinstances"><code>staleinstances</code></a>:</p><pre><code class="language-julia hljs">julia&gt; staleinstances(tinf)
SnoopCompileCore.InferenceTiming[]</code></pre><p>If you see this, all&#39;s well. A non-empty list might indicate method invalidations, which can be checked (in a fresh session) by running the identical workload with <a href="../reference/#SnoopCompileCore.@snoopr"><code>@snoopr</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Rampant invalidation can make the process of analyzing <code>tinf</code> more confusing: &quot;why am I getting reinference of this <code>MethodInstance</code> when I <code>precompile</code>d it?&quot; Routine use of <code>staleinstances</code> at the beginning can save you some head-scratching later.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Your workload may load packages and/or (re)define methods; these can be sources of invalidation and therefore non-empty output from <code>staleinstances</code>. One trick that may circumvent some invalidation is to load the packages and make the method definitions before launching <code>@snoopi_deep</code>, because it ensures the methods are in place before your workload triggers compilation.</p></div></div><p>If you do have a lot of invalidations, <a href="../reference/#SnoopCompile.precompile_blockers"><code>precompile_blockers</code></a> may be an effective way to reveal those invalidations that affect your particular package and workload.</p><h2 id="Viewing-the-results"><a class="docs-heading-anchor" href="#Viewing-the-results">Viewing the results</a><a id="Viewing-the-results-1"></a><a class="docs-heading-anchor-permalink" href="#Viewing-the-results" title="Permalink"></a></h2><p>Let&#39;s start unpacking the output of <code>@snoopi_deep</code> and see how to get more insight. First, notice that the output is an <code>InferenceTimingNode</code>: it&#39;s the root element of a tree of such nodes, all connected by caller-callee relationships. Indeed, this particular node is for <code>Core.Compiler.Timings.ROOT()</code>, a &quot;dummy&quot; node that is the root of all such trees.</p><p>You may have noticed that this <code>ROOT</code> node prints with two numbers. It will be easier to understand their meaning if we first display the whole tree. We can do that with the <a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees</a> package:</p><pre><code class="language-julia-repl hljs">julia&gt; using AbstractTrees

julia&gt; print_tree(tinf)
InferenceTimingNode: 0.002712/0.003278 on Core.Compiler.Timings.ROOT() with 1 direct children
└─ InferenceTimingNode: 0.000133/0.000566 on FlattenDemo.packintype(::Int64) with 2 direct children
   ├─ InferenceTimingNode: 0.000094/0.000094 on FlattenDemo.MyType{Int64}(::Int64) with 0 direct children
   └─ InferenceTimingNode: 0.000089/0.000339 on FlattenDemo.dostuff(::FlattenDemo.MyType{Int64}) with 2 direct children
      ├─ InferenceTimingNode: 0.000064/0.000122 on FlattenDemo.extract(::FlattenDemo.MyType{Int64}) with 2 direct children
      │  ├─ InferenceTimingNode: 0.000034/0.000034 on getproperty(::FlattenDemo.MyType{Int64}, ::Symbol) with 0 direct children
      │  └─ InferenceTimingNode: 0.000024/0.000024 on getproperty(::FlattenDemo.MyType{Int64}, x::Symbol) with 0 direct children
      └─ InferenceTimingNode: 0.000127/0.000127 on FlattenDemo.domath(::Int64) with 0 direct children</code></pre><p>This tree structure reveals the caller-callee relationships, showing the specific types that were used for each <code>MethodInstance</code>. Indeed, as the calls to <code>getproperty</code> reveal, it goes beyond the types and even shows the results of <a href="https://en.wikipedia.org/wiki/Constant_folding">constant propagation</a>; the <code>getproperty(::MyType{Int64}, x::Symbol)</code> (note <code>x::Symbol</code> instead of just plain <code>::Symbol</code>) means that the call was <code>getproperty(y, :x)</code>, which corresponds to <code>y.x</code> in the definition of <code>extract</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Generally we speak of <a href="https://en.wikipedia.org/wiki/Call_graph">call graphs</a> rather than call trees. But because inference results are cached (a.k.a., we only &quot;visit&quot; each node once), we obtain a tree as a depth-first-search of the full call graph.</p></div></div><p>You can extract the <code>MethodInstance</code> with</p><pre><code class="language-julia-repl hljs">julia&gt; Core.MethodInstance(tinf)
MethodInstance for Core.Compiler.Timings.ROOT()

julia&gt; Core.MethodInstance(tinf.children[1])
MethodInstance for FlattenDemo.packintype(::Int64)</code></pre><p>Each node in this tree is accompanied by a pair of numbers. The first number is the <em>exclusive</em> inference time (in seconds), meaning the time spent inferring the particular <code>MethodInstance</code>, not including the time spent inferring its callees. The second number is the <em>inclusive</em> time, which is the exclusive time plus the time spent on the callees. Therefore, the inclusive time is always at least as large as the exclusive time.</p><p>The <code>ROOT</code> node is a bit different: its exclusive time measures the time spent on all operations <em>except</em> inference. In this case, we see that the entire call took approximately 10ms, of which 9.3ms was spent on activities besides inference. Almost all of that was code-generation, but it also includes the time needed to run the code. Just 0.76ms was needed to run type-inference on this entire series of calls. As you will quickly discover, inference takes much more time on more complicated code.</p><p>We can also display this tree as a flame graph, using the <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> package:</p><pre><code class="language-julia-repl hljs">julia&gt; fg = flamegraph(tinf)
Node(FlameGraphs.NodeData(ROOT() at typeinfer.jl:75, 0x00, 0:10080857))</code></pre><pre><code class="language-julia hljs">julia&gt; using ProfileView

julia&gt; ProfileView.view(fg)</code></pre><p>You should see something like this:</p><p><img src="../assets/flamegraph-flatten-demo.png" alt="flamegraph"/></p><p>Users are encouraged to read the ProfileView documentation to understand how to interpret this, but briefly:</p><ul><li>the horizontal axis is time (wide boxes take longer than narrow ones), the vertical axis is call depth</li><li>hovering over a box displays the method that was inferred</li><li>left-clicking on a box causes the full <code>MethodInstance</code> to be printed in your REPL session</li><li>right-clicking on a box opens the corresponding method in your editor</li><li>ctrl-click can be used to zoom in</li><li>empty horizontal spaces correspond to activities other than type-inference</li><li>any boxes colored red (there are none in this particular example, but you&#39;ll see some later) correspond to <em>non-precompilable</em> <code>MethodInstance</code>s, in which the method is owned by one module but the types are from another unrelated module.</li><li>any boxes colored orange-yellow (there is one in this demo) correspond to methods inferred for specific constants (constant propagation)</li></ul><p>You can explore this flamegraph and compare it to the output from <code>print_tree</code>.</p><p>Finally, <a href="../reference/#SnoopCompile.flatten"><code>flatten</code></a>, on its own or together with <a href="../reference/#SnoopCompile.accumulate_by_source"><code>accumulate_by_source</code></a>, allows you to get an sense for the cost of individual <code>MethodInstance</code>s or <code>Method</code>s.</p><p>The tools here allow you to get an overview of where inference is spending its time. Sometimes, this information alone is enough to show you how to change your code to reduce latency: perhaps your code is spending a lot of time inferring cases that are not needed in practice and could be simplified. However, most efforts at latency reduction will probably leverage additional tools (described next) that help identify the main opportunities for intervention.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../snoopr/">« Snooping on and fixing invalidations: <code>@snoopr</code></a><a class="docs-footer-nextpage" href="../pgdsgui/">Profile-guided despecialization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 6 February 2024 09:45">Tuesday 6 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
