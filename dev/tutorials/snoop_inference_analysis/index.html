<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using @snoop_inference results to improve inferrability · SnoopCompile</title><meta name="title" content="Using @snoop_inference results to improve inferrability · SnoopCompile"/><meta property="og:title" content="Using @snoop_inference results to improve inferrability · SnoopCompile"/><meta property="twitter:title" content="Using @snoop_inference results to improve inferrability · SnoopCompile"/><meta name="description" content="Documentation for SnoopCompile."/><meta property="og:description" content="Documentation for SnoopCompile."/><meta property="twitter:description" content="Documentation for SnoopCompile."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SnoopCompile</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SnoopCompile.jl</a></li><li><span class="tocitem">Basic tutorials</span><ul><li><a class="tocitem" href="../invalidations/">Tutorial on <code>@snoop_invalidations</code></a></li><li><a class="tocitem" href="../snoop_inference/">Tutorial on <code>@snoop_inference</code></a></li><li><a class="tocitem" href="../snoop_llvm/">Tutorial on <code>@snoop_llvm</code></a></li><li><a class="tocitem" href="../pgdsgui/">Profile-guided despecialization</a></li></ul></li><li><span class="tocitem">Advanced tutorials</span><ul><li class="is-active"><a class="tocitem" href>Using <code>@snoop_inference</code> results to improve inferrability</a><ul class="internal"><li><a class="tocitem" href="#Analyzing-inference-triggers"><span>Analyzing inference triggers</span></a></li><li><a class="tocitem" href="#test-suites"><span>A note on analyzing test suites</span></a></li></ul></li><li><a class="tocitem" href="../snoop_inference_parcel/">Using <code>@snoop_inference</code> to emit manual precompile directives</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../explanations/tools/">Package roles and alternatives</a></li><li><a class="tocitem" href="../../explanations/gotchas/">Precompilation &quot;gotcha&quot;s</a></li><li><a class="tocitem" href="../../explanations/fixing_inference/">Techniques for fixing inference problems</a></li><li><a class="tocitem" href="../../explanations/invalidation_classes/">Invalidation classes</a></li><li><a class="tocitem" href="../../explanations/devs/">Information for SnoopCompile developers</a></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced tutorials</a></li><li class="is-active"><a href>Using <code>@snoop_inference</code> results to improve inferrability</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using <code>@snoop_inference</code> results to improve inferrability</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDebug/SnoopCompile.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDebug/SnoopCompile.jl/blob/master/docs/src/tutorials/snoop_inference_analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="inferrability"><a class="docs-heading-anchor" href="#inferrability">Using <code>@snoop_inference</code> results to improve inferrability</a><a id="inferrability-1"></a><a class="docs-heading-anchor-permalink" href="#inferrability" title="Permalink"></a></h1><p>Throughout this page, we&#39;ll use the <code>OptimizeMe</code> demo, which ships with <code>SnoopCompile</code>.</p><div class="admonition is-info" id="Note-8321a2af9aae113b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8321a2af9aae113b" title="Permalink"></a></header><div class="admonition-body"><p>To understand what follows, it&#39;s essential to refer to <a href="https://github.com/timholy/SnoopCompile.jl/blob/master/examples/OptimizeMe.jl"><code>OptimizeMe</code> source code</a> as you follow along.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SnoopCompileCore, SnoopCompile # here we need the SnoopCompile path for the next line (normally you should wait until after data collection is complete)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; include(joinpath(pkgdir(SnoopCompile), &quot;examples&quot;, &quot;OptimizeMe.jl&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">Main.var&quot;Main&quot;.OptimizeMe</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tinf = @snoop_inference OptimizeMe.main();</code><code class="nohighlight hljs ansi" style="display:block;">lotsa containers:</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fg = flamegraph(tinf)</code><code class="nohighlight hljs ansi" style="display:block;">Node(FlameGraphs.NodeData(ROOT() at typeinfer.jl:66, 0x00, 0:2952868938))</code></pre><p>If you visualize <code>fg</code> with ProfileView, you may see something like this:</p><p><img src="../../assets/flamegraph-OptimizeMe.png" alt="flamegraph-OptimizeMe"/></p><p>From the standpoint of precompilation, this has some obvious problems:</p><ul><li>even though we called a single method, <code>OptimizeMe.main()</code>, there are many distinct flames separated by blank spaces. This indicates that many calls are being made by runtime dispatch:  each separate flame is a fresh entrance into inference.</li><li>several of the flames are marked in red, indicating that they are not naively precompilable (see the <a href="../snoop_inference/#Tutorial-on-@snoop_inference">Tutorial on <code>@snoop_inference</code></a>). While <code>@compile_workload</code> can handle these flames, an even more robust solution is to eliminate them altogether.</li></ul><p>Our goal will be to improve the design of <code>OptimizeMe</code> to make it more readily precompilable.</p><h2 id="Analyzing-inference-triggers"><a class="docs-heading-anchor" href="#Analyzing-inference-triggers">Analyzing inference triggers</a><a id="Analyzing-inference-triggers-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-inference-triggers" title="Permalink"></a></h2><p>We&#39;ll first extract the &quot;triggers&quot; of inference, which is just a repackaging of part of the information contained within <code>tinf</code>. Specifically an <a href="../../reference/#SnoopCompile.InferenceTrigger"><code>InferenceTrigger</code></a> captures callee/caller relationships that straddle a fresh entrance to type-inference, allowing you to identify which calls were made by runtime dispatch and what <code>MethodInstance</code> they called.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; itrigs = inference_triggers(tinf)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: it seems you&#39;ve supplied a child node, but backtraces are collected only at the entrance to inference: InferenceTimingNode: 0.000922/0.011567 on Base.afoldl(::Base.var&quot;#promote_typeof##0#promote_typeof##1&quot;, ::Type, ::Float32, ::Char, ::Vector{Int64}, ::Tuple{String, Int64}) with 4 direct children</code></pre><p>The number of elements in this <code>Vector{InferenceTrigger}</code> tells you how many calls were (1) made by runtime dispatch and (2) the callee had not previously been inferred.</p><div class="admonition is-success" id="Tip-a491491705bdcc40"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-a491491705bdcc40" title="Permalink"></a></header><div class="admonition-body"><p>In the REPL, <code>SnoopCompile</code> displays <code>InferenceTrigger</code>s with yellow coloration for the callee, red for the caller method, and blue for the caller specialization. This makes it easier to quickly identify the most important information.</p></div></div><p>In some cases, this might indicate that you&#39;ll need to fix each case separately; fortunately, in many cases fixing one problem addresses many other.</p><h3 id="methtrigs"><a class="docs-heading-anchor" href="#methtrigs">Method triggers</a><a id="methtrigs-1"></a><a class="docs-heading-anchor-permalink" href="#methtrigs" title="Permalink"></a></h3><p>Most often, it&#39;s most convenient to organize them by the method triggering the need for inference:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mtrigs = accumulate_by_source(Method, itrigs)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `itrigs` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code></pre><p>The methods triggering the largest number of inference runs are shown at the bottom. You can also select methods from a particular module:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; modtrigs = filtermod(OptimizeMe, mtrigs)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `mtrigs` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code></pre><p>Rather than filter by a single module, you can alternatively call <code>SnoopCompile.parcel(mtrigs)</code> to split them out by module. In this case, most of the triggers came from <code>Base</code>, not <code>OptimizeMe</code>. However, many of the failures in <code>Base</code> were nevertheless indirectly due to <code>OptimizeMe</code>: our methods in <code>OptimizeMe</code> call <code>Base</code> methods with arguments that trigger internal inference failures. Fortunately, we&#39;ll see that using more careful design in <code>OptimizeMe</code> can avoid many of those problems.</p><div class="admonition is-success" id="Tip-ee6064960999d9e"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-ee6064960999d9e" title="Permalink"></a></header><div class="admonition-body"><p>If you have a longer list of inference triggers than you feel comfortable tackling, filtering by your package&#39;s module or using <a href="../../reference/#SnoopCompile.precompile_blockers"><code>precompile_blockers</code></a> can be a good way to start. Fixing issues in the package itself can end up resolving many of the &quot;indirect&quot; triggers too. Also be sure to note the ability to filter out likely &quot;noise&quot; from <a href="#test-suites">test suites</a>.</p></div></div><p>You can get an overview of each Method trigger with <code>summary</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mtrig = modtrigs[1]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `modtrigs` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; summary(mtrig)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `mtrig` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code></pre><p>You can also say <code>edit(mtrig)</code> and be taken directly to the method you&#39;re analyzing in your editor. You can still &quot;dig deep&quot; into individual triggers:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; itrig = mtrig.itrigs[1]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `mtrig` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code></pre><p>This is useful if you want to analyze with <code>Cthulhu.ascend</code>. <code>Method</code>-based triggers, which may aggregate many different individual triggers, can be useful because tools like <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a> show you the inference results for the entire <code>MethodInstance</code>, allowing you to fix many different inference problems at once.</p><h3 id="Trigger-trees"><a class="docs-heading-anchor" href="#Trigger-trees">Trigger trees</a><a id="Trigger-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Trigger-trees" title="Permalink"></a></h3><p>While method triggers are probably the most useful way of organizing these inference triggers, for learning purposes here we&#39;ll use a more detailed scheme, which organizes inference triggers in a tree:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; itree = trigger_tree(itrigs)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `itrigs` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AbstractTrees</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(itree)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `itree` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code></pre><p>This gives you a big-picture overview of how the inference failures arose. The parent-child relationships are based on the backtraces at the entrance to inference, and the nodes are organized in the order in which inference occurred. Inspection of these trees can be informative; for example, here we notice a lot of method specializations for <code>Container{T}</code> for different <code>T</code>.</p><p>We&#39;re going to march through these systematically.</p><h3 id="suggest-and-fixing-Core.Box"><a class="docs-heading-anchor" href="#suggest-and-fixing-Core.Box"><code>suggest</code> and fixing <code>Core.Box</code></a><a id="suggest-and-fixing-Core.Box-1"></a><a class="docs-heading-anchor-permalink" href="#suggest-and-fixing-Core.Box" title="Permalink"></a></h3><p>You may have noticed above that <code>summary(mtrig)</code> generated a red <code>has Core.Box</code> message. Assuming that <code>itrig</code> is still the first (and it turns out, only) trigger from this method, let&#39;s look at this again, explicitly using <a href="../../reference/#SnoopCompile.suggest"><code>suggest</code></a>, the tool that generated this hint:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; suggest(itrig)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `itrig` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code></pre><p>You can see that SnoopCompile recommends tackling this first; depending on how much additional code is affected, fixing a  <code>Core.Box</code> allows inference to work better and may resolve other triggers.</p><p>This message also directs readers to a section of <a href="../../explanations/fixing_inference/#Fixing-Core.Box">this documentation</a> that links to a page of the Julia manual describing the underlying problem. The Julia documentation suggests a couple of fixes, of which the best (in this case) is to use the <code>let</code> statement to rebind the variable and end any &quot;conflict&quot; with the closure:</p><pre><code class="nohighlight hljs">function abmult(r::Int, ys)
    if r &lt; 0
        r = -r
    end
    let r = r    # Julia #15276
        return map(x -&gt; howbig(r * x), ys)
    end
end</code></pre><h3 id="suggest-and-a-fix-involving-manual-eltype-specification"><a class="docs-heading-anchor" href="#suggest-and-a-fix-involving-manual-eltype-specification"><code>suggest</code> and a fix involving manual <code>eltype</code> specification</a><a id="suggest-and-a-fix-involving-manual-eltype-specification-1"></a><a class="docs-heading-anchor-permalink" href="#suggest-and-a-fix-involving-manual-eltype-specification" title="Permalink"></a></h3><p>Let&#39;s look at the other Method-trigger rooted in <code>OptimizeMe</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mtrig = modtrigs[2]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `modtrigs` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; summary(mtrig)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `mtrig` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; itrig = mtrig.itrigs[1]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `mtrig` not defined in `Main.var&quot;Main&quot;`
Suggestion: add an appropriate import or assignment. This global was declared but not assigned.</code></pre><p>If you use Cthulhu&#39;s <code>ascend(itrig)</code> you might see something like this:</p><p><img src="../../assets/ascend_optimizeme1.png" alt="ascend-lotsa"/></p><p>The first thing to note here is that <code>cs</code> is inferred as an <code>AbstractVector</code>–fixing this to make it a concrete type should be our next goal. There&#39;s a second, more subtle hint: in the call menu at the bottom, the selected call is marked <code>&lt; semi-concrete eval &gt;</code>. This is a hint that a method is being called with a non-concrete type.</p><p>What might that non-concrete type be?</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; isconcretetype(OptimizeMe.Container)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>The statement <code>Container.(list)</code> is thus creating an <code>AbstractVector</code> with a non-concrete element type. You can seem in greater detail what happens, inference-wise, in this snippet from <code>print_tree(itree)</code>:</p><pre><code class="nohighlight hljs">   ├─ similar(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, Type{Main.OptimizeMe.Container}, Tuple{Base.Broadcast.Extruded{Vector{Any}, Tuple{Bool}, Tuple{Int64}}}}, ::Type{Main.OptimizeMe.Container{Int64}})
   ├─ setindex!(::Vector{Main.OptimizeMe.Container{Int64}}, ::Main.OptimizeMe.Container{Int64}, ::Int64)
   ├─ Base.Broadcast.copyto_nonleaf!(::Vector{Main.OptimizeMe.Container{Int64}}, ::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, Type{Main.OptimizeMe.Container}, Tuple{Base.Broadcast.Extruded{Vector{Any}, Tuple{Bool}, Tuple{Int64}}}}, ::Base.OneTo{Int64}, ::Int64, ::Int64)
   │  ├─ similar(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Tuple{Base.OneTo{Int64}}, Type{Main.OptimizeMe.Container}, Tuple{Base.Broadcast.Extruded{Vector{Any}, Tuple{Bool}, Tuple{Int64}}}}, ::Type{Main.OptimizeMe.Container})
   │  └─ Base.Broadcast.restart_copyto_nonleaf!(::Vector{Main.OptimizeMe.Container}, ::Vector{Main.OptimizeMe.Container{Int64}}, ::Base.Broadcast.Broadcasted</code></pre><p>In rough terms, what this means is the following:</p><ul><li>since the first item in <code>list</code> is an <code>Int</code>, the output initially gets created as a <code>Vector{Container{Int}}</code></li><li>however, <code>copyto_nonleaf!</code> runs into trouble when it goes to copy the second item, which is a <code>Container{UInt8}</code></li><li>hence, <code>copyto_nonleaf!</code> re-allocates the output array to be a generic <code>Vector{Container}</code> and then calls <code>restart_copyto_nonleaf!</code>.</li></ul><p>We can prevent all this hassle with one simple change: rewrite that line as</p><pre><code class="nohighlight hljs">cs = Container{Any}.(list)</code></pre><p>We use <code>Container{Any}</code> here because there is no more specific element type–other than an unreasonably-large <code>Union</code>–that can hold all the items in <code>list</code>.</p><p>If you make these edits manually, you&#39;ll see that we&#39;ve gone from dozens of <code>itrigs</code> (38 on Julia 1.10, you may get a different number on other Julia versions) down to about a dozen (13 on Julia 1.10). Real progress!</p><h3 id="Replacing-hard-to-infer-calls-with-lower-level-APIs"><a class="docs-heading-anchor" href="#Replacing-hard-to-infer-calls-with-lower-level-APIs">Replacing hard-to-infer calls with lower-level APIs</a><a id="Replacing-hard-to-infer-calls-with-lower-level-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#Replacing-hard-to-infer-calls-with-lower-level-APIs" title="Permalink"></a></h3><p>We note that many of the remaining triggers are somehow related to <code>show</code>, for example:</p><pre><code class="nohighlight hljs">Inference triggered to call show(::IOContext{Base.TTY}, ::MIME{Symbol(&quot;text/plain&quot;)}, ::Vector{Main.OptimizeMe.Container{Any}}) from #55 (/cache/build/builder-amdci4-0/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:273) with specialization (::REPL.var&quot;#55#56&quot;{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(&quot;text/plain&quot;)}, Base.RefValue{Any}})(::Any)</code></pre><p>In this case we see that the calling method is <code>#55</code>.  This is a <code>gensym</code>, or generated symbol, indicating that the method was generated during Julia&#39;s lowering pass, and might indicate a macro, a <code>do</code> block or other anonymous function, the generator for a <code>@generated</code> function, etc.</p><p><code>edit(itrig)</code> (or equivalently, <code>edit(node)</code> where <code>node</code> is a child of <code>itree</code>) takes us to this method in <code>Base</code>, for which key lines are</p><pre><code class="language-julia hljs">function display(d::REPLDisplay, mime::MIME&quot;text/plain&quot;, x)
    x = Ref{Any}(x)
    with_repl_linfo(d.repl) do io
        ⋮
        show(io, mime, x[])
        ⋮
end</code></pre><p>The generated method corresponds to the <code>do</code> block here. The call to <code>show</code> comes from <code>show(io, mime, x[])</code>. This implementation uses a clever trick, wrapping <code>x</code> in a <code>Ref{Any}(x)</code>, to prevent specialization of the method defined by the <code>do</code> block on the specific type of <code>x</code>. This trick is designed to limit the number of <code>MethodInstance</code>s inferred for this <code>display</code> method.</p><p>A great option is to replace the call to <code>display</code> with an explicit</p><pre><code class="nohighlight hljs">show(stdout, MIME(&quot;text/plain&quot;), cs)</code></pre><p>There&#39;s one extra detail: the type of <code>stdout</code> is not fixed (and therefore not known), because one can use a terminal, a file, <code>devnull</code>, etc., as <code>stdout</code>. If you want to prevent all runtime dispatch from this call, you&#39;d need to supply an <code>io::IO</code> object of known type as the first argument. It could, for example, be passed in to <code>lotsa_containers</code> from <code>main</code>:</p><pre><code class="nohighlight hljs">function lotsa_containers(io::IO)
    ⋮
    println(io, &quot;lotsa containers:&quot;)
    show(io, MIME(&quot;text/plain&quot;), cs)
end</code></pre><p>However, if you want it to go to <code>stdout</code>–and to allow users to redirect <code>stdout</code> to a target of their choosing–then an <code>io</code> argument may have to be of unknown type when called from <code>main</code>.</p><h3 id="When-you-need-to-rely-on-@compile_workload"><a class="docs-heading-anchor" href="#When-you-need-to-rely-on-@compile_workload">When you need to rely on <code>@compile_workload</code></a><a id="When-you-need-to-rely-on-@compile_workload-1"></a><a class="docs-heading-anchor-permalink" href="#When-you-need-to-rely-on-@compile_workload" title="Permalink"></a></h3><p>Most of the remaining triggers are difficult to fix because they occur in deliberately-<code>@nospecialize</code>d portions of Julia&#39;s internal code for displaying arrays. In such cases, adding a <code>PrecompileTools.@compile_workload</code> is your best option. Here we use an interesting trick:</p><pre><code class="nohighlight hljs">@compile_workload begin
    lotsa_containers(devnull)  # use `devnull` to suppress output
    abmult(rand(-5:5), rand(3))
end
precompile(lotsa_containers, (Base.TTY,))</code></pre><p>During the workload, we pass <code>devnull</code> as the <code>io</code> object to <code>lotsa_containers</code>: this suppresses the output so you don&#39;t see anything during precompilation. However, <code>devnull</code> is not a <code>Base.TTY</code>, the standard type of <code>stdout</code>. Nevertheless, this is effective because we can see that many of the callees in the remaining inference-triggers do not depend on the <code>io</code> object.</p><p>To really ice the cake, we also add a manual <code>precompile</code> directive. (<code>precompile</code> doesn&#39;t execute the method, it just compiles it.) This doesn&#39;t &quot;step through&quot; runtime dispatch, but at least it precompiles the entry point. Thus, at least <code>lotsa_containers</code> will be precompiled for the most likely <code>IO</code> type encountered in practice.</p><p>With these changes, we&#39;ve fixed nearly all the latency problems in <code>OptimizeMe</code>, and made it much less vulnerable to invalidation as well. You can see the final code in the <a href="https://github.com/timholy/SnoopCompile.jl/blob/master/examples/OptimizeMeFixed.jl"><code>OptimizeMeFixed</code> source code</a>. Note that this would have to be turned into a real package for the <code>@compile_workload</code> to have any effect.</p><h2 id="test-suites"><a class="docs-heading-anchor" href="#test-suites">A note on analyzing test suites</a><a id="test-suites-1"></a><a class="docs-heading-anchor-permalink" href="#test-suites" title="Permalink"></a></h2><p>If you&#39;re doing a package analysis, it&#39;s convenient to use the package&#39;s <code>runtests.jl</code> script as a way to cover much of the package&#39;s functionality. SnoopCompile has a couple of enhancements designed to make it easier to ignore inference triggers that come from the test suite itself. First, <code>suggest.(itrigs)</code> may show something like this:</p><pre><code class="nohighlight hljs"> ./broadcast.jl:1315: inlineable (ignore this one)
 ./broadcast.jl:1315: inlineable (ignore this one)
 ./broadcast.jl:1315: inlineable (ignore this one)
 ./broadcast.jl:1315: inlineable (ignore this one)</code></pre><p>This indicates a broadcasting operation in the <code>@testset</code> itself. Second, while it&#39;s a little dangerous (because <code>suggest</code> cannot entirely be trusted), you can filter these out:</p><pre><code class="language-julia hljs">julia&gt; itrigsel = [itrig for itrig in itrigs if !isignorable(suggest(itrig))];

julia&gt; length(itrigs)
222

julia&gt; length(itrigsel)
71</code></pre><p>While there is some risk of discarding triggers that provide clues about the origin of other triggers (e.g., they would have shown up in the same branch of the <code>trigger_tree</code>), the shorter list may help direct your attention to the &quot;real&quot; issues.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pgdsgui/">« Profile-guided despecialization</a><a class="docs-footer-nextpage" href="../snoop_inference_parcel/">Using <code>@snoop_inference</code> to emit manual precompile directives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 26 September 2025 09:07">Friday 26 September 2025</span>. Using Julia version 1.12.0-rc2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
