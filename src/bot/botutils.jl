################################################################
"""
    timesum(snoop::Vector{Tuple{Float64, Core.MethodInstance}}, unit = :s)

Calculates and prints the total time measured by a snoop macro. `unit` can be :s or :ms.

It is used inside @snoopi_bench. Julia can cache inference results so to measure the effect of adding _precompile_() sentences generated by snoopi to your package, use the [`@snoopi_bench`](@ref). This benchmark measures inference time taken during loading and running of a package.

# Examples
```julia
using SnoopCompile
data = @snoopi begin
    using MatLang
    MatLang_rootpath = dirname(dirname(pathof("MatLang")))

    include("\$MatLang_rootpath/test/runtests.jl")
end
println(timesum(data, :ms))
```

## Manual Benchmark (withtout using [`@snoopi_bench`](@ref))
- dev your package

- comment the precompile part of your package (`include()` and `_precompile_()`)
- run the following benchmark
- restart Julia

- uncomment the precompile part of your package (`include()` and `_precompile_()`)
- run the following benchmark
- restart Julia

### Benchmark
```julia
using SnoopCompile

println("Package load time:")
loadSnoop = @snoopi using MatLang

timesum(loadSnoop)

println("Running Examples/Tests:")
runSnoop = @snoopi begin
    using MatLang

    MatLang_rootpath = dirname(dirname(pathof("MatLang")))
    include("\$MatLang_rootpath/test/runtests.jl")
end

timesum(runSnoop)
```
"""
function timesum(snoop::Vector{Tuple{Float64, Core.MethodInstance}}, unit::Symbol = :s)
    if isempty(snoop)
        t = 0.0
    else
        t = sum(first, snoop)
    end
    if unit == :s
        t = round(t, digits = 6)
    elseif unit == :ms
        t = round(t * 100, digits = 3)
    else
        throw(ArgumentError("unit should be `:s` or `:ms`"))
    end
    return t
end
################################################################
"""
    detectOS()

Returns Operating System of a machine as a string as the 1st output and the osfun as the 2nd output.
"""
function detectOS()
allos_funs = [
         Sys.iswindows,
         Sys.isapple,
         Sys.islinux,
         Sys.isbsd,
         Sys.isdragonfly,
         Sys.isfreebsd,
         Sys.isnetbsd,
         Sys.isopenbsd,
         Sys.isjsvm]
    os = ""
    osfun = allos_funs[1] # temp
    for osfun in allos_funs
        if osfun()
            os = string(osfun)[3:end]
            break
        end
    end
    if os == ""
        @error "os is not detected"
    end
    return os, osfun
end
################################################################
"""
Standardize different names from Github actions, Travis, etc

https://help.github.com/en/actions/reference/virtual-environments-for-github-hosted-runners#supported-runners-and-hardware-resources
"""
function standardize_osname(os::Vector{String})
    os[occursin.("macos", os)] .= "apple"
    os[occursin.("osx", os)] .= "apple"
    os[occursin.("apple", os)] .= "apple"
    os[occursin.("ubuntu", os)] .= "linux"
    os[occursin.("linux", os)] .= "linux"
    os[occursin.("windows", os)] .= "windows"
    return os
end
function standardize_osname(else_os::String)
    occursin.("macos", else_os) ? else_os = "apple" : nothing
    occursin.("osx", else_os) ? else_os = "apple" : nothing
    occursin.("apple", else_os) ? else_os = "apple" : nothing
    occursin.("ubuntu", else_os) ? else_os = "linux" : nothing
    occursin.("linux", else_os) ? else_os = "linux" : nothing
    occursin.("windows", else_os) ? else_os = "windows" : nothing
    return else_os
end
standardize_osname(input::Nothing) = input
################################################################

using FilePathsBase

export GoodPath
# to convert WindowsPath before they get inside the SnoopCompile code
# GoodPath(inp::String) = inp |> Path |> _GoodPath |> string
# _GoodPath(path::WindowsPath) = PosixPath((path.drive, path.segments...))
# _GoodPath(path) = path
GoodPath(x::String) = replace(x, "\\" => "/") # doesn't remove / from the end of the strings
goodjoinpath(args...) = GoodPath(joinpath(args...))

################################################################
"""
     searchdir(rootpath::String, pattern::AbstractString)
a function to search a directory.
```julia
julia> searchdir("src", "/bot.jl")
1-element Array{String,1}:
 "src/bot.jl"
```
"""
function searchdir(rootpath::String, pattern::AbstractString)
    found_files = String[]
    for file in walkpath(Path(rootpath))
        if occursin(pattern, GoodPath(string(file)))
            push!(found_files, GoodPath(string(file)))
        end
    end
    return found_files
end

"""
Searches for the file rather a path.
"""
searchdirfile(rootpath::String, file::AbstractString) = searchdir(rootpath, string(Path(file).segments[end]))

"""
    searchdirs(rootpaths::Array{String}, pattern::AbstractString)

a function to search multiple directories.

```julia
julia> searchdirs(["./src", "./test"], "/bot.jl")
2-element Array{String,1}:
 "./src/bot.jl"
 "./test/bot/bot.jl"
```
"""
function searchdirs(rootpaths::Array{String}, pattern::AbstractString)
    unique(
        reduce(vcat,
            searchdir.(rootpaths, pattern)
        )
    )
end

"""
Searches for the file rather a path.
"""
searchdirsfile(rootpaths::Array{String}, file::AbstractString) = searchdirs(rootpaths, basename(file))

"""
search for the script! - needed because of confusing paths when referencing pattern_or_file in CI
"""
function searchdirsboth(rootpaths::Array{String}, pattern_or_file::AbstractString)
    if isfile(pattern_or_file)
        return pattern_or_file
    elseif isfile("../../$pattern_or_file") # if in deps/SnoopCompile
        return "../../$pattern_or_file"
    else
        found_files = searchdirs(rootpaths, pattern_or_file)
        if length(found_files) === 0
            found_files = searchdirsfiles(rootpaths, pattern_or_file)
            if length(found_files) === 0
                @error "Couldn't find $(pattern_or_file)"
            elseif length(found_files) > 1
                @error "Multiple $(pattern_or_file) exists at the current directory."
            else
                pattern_or_file = found_files[1]
            end
        elseif length(found_files) > 1
            @error "Multiple $(pattern_or_file) exists at the current directory."
        else
            pattern_or_file = found_files[1]
        end
    end
    return pattern_or_file
end
################################################################

export pathof_noload

"""
Returns a package's path without loading the package in the main Julia process.
# Examples
```julia
pathof_noload("MatLang")
```
"""
function pathof_noload(package_name::String)
    path = Base.find_package(package_name)
    if isnothing(path)
        cmd = "import $package_name; print(pathof($package_name))"
        try
            path = Base.read(`julia -e $cmd`, String)
            return GoodPath(path)
        catch
            try
                path = Base.read(`julia --project=@. -e $cmd`, String)
                return GoodPath(path)
            catch
                @error "Couldn't find the path of $package_name"
            end
        end
    else
        return GoodPath(path)
    end
end

################################################################

import Pkg
"""
Should be removed once Pkg allows adding test dependencies to the current environment

Used in Github Action workflow yaml file
"""
function addtestdep()

    if isfile("test/Test.toml")
        toml = Pkg.TOML.parsefile("test/Test.toml")
        test_deps = get(toml, "deps", nothing)
    elseif isfile("test/Project.toml")
        toml = Pkg.TOML.parsefile("test/Project.toml")
        test_deps = get(toml, "deps", nothing)
    else
        toml = Pkg.TOML.parsefile("Project.toml")
        test_deps = get(toml, "extras", nothing)
    end

    if !isnothing(test_deps)
        for (name, uuid) in test_deps
            Pkg.add(Pkg.PackageSpec(name = name, uuid = uuid))
        end
    end
end
