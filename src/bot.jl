export precompileActivator, precompileDeactivator, precompilePather, @snoopiBot, @snoopiBenchBot, BotConfig

"""
    precompilePather(packageName::String)

To get the path of precompile_packageName.jl file

Written exclusively for SnoopCompile Github actions.
# Examples
```julia
precompilePath, precompileFolder = precompilePather("MatLang")
```
"""
function precompilePather(packageName::String)
    return "\"../deps/SnoopCompile/precompile/precompile_$packageName.jl\"",
    "$(pwd())/deps/SnoopCompile/precompile/"
end

precompilePather(packageName::Symbol) = precompilePather(string(packageName))
precompilePather(packageName::Module) = precompilePather(string(packageName))

################################################################

function precompileRegex(precompilePath)
    # https://stackoverflow.com/questions/3469080/match-whitespace-but-not-newlines
    # {1,} for any number of spaces
    c1 = Regex("#[^\\S\\r\\n]{0,}include\\($(precompilePath)\\)")
    c2 = r"#\s{0,}_precompile_\(\)"
    a1 = "include($precompilePath)"
    a2 = "_precompile_()"
    return c1, c2, a1, a2
end
################################################################

"""
    precompileActivator(packagePath, precompilePath)

Activates precompile of a package by adding or uncommenting include() of *.jl file generated by SnoopCompile and _precompile_().

Written exclusively for SnoopCompile Github actions.
"""
function precompileActivator(packagePath::String, precompilePath::String)

    file = open(packagePath,"r")
    packageText = Base.read(file, String)
    close(file)

    c1, c2, a1, a2 = precompileRegex(precompilePath)

    # Checking availability of _precompile_ code
    commented = occursin(c1, packageText) && occursin(c2, packageText)
    available = occursin(a1, packageText) && occursin(a2, packageText)

    if commented
        packageEdited = foldl(replace,
                     (
                      c1 => a1,
                      c2 => a2,
                     ),
                     init = packageText)

                     file = open(packagePath,"w")
                     Base.write(file, packageEdited)
                     close(file)
        println("precompile is activated")
    elseif available
        # do nothing
        println("precompile is already activated")
    else
        # TODO: add code automatiaclly
        error(""" add the following codes into your package:
         #include($precompilePath)
         #_precompile_()
         """)
    end

end

"""
    precompileDeactivator(packagePath, precompilePath)

Deactivates precompile of a package by commenting include() of *.jl file generated by SnoopCompile and _precompile_().

Written exclusively for SnoopCompile Github actions.
"""
function precompileDeactivator(packagePath::String, precompilePath::String)

    file = open(packagePath,"r")
    packageText = Base.read(file, String)
    close(file)

    c1, c2, a1, a2 = precompileRegex(precompilePath)

    # Checking availability of _precompile_ code
    commented = occursin(c1, packageText) && occursin(c2, packageText)
    available = occursin(a1, packageText) && occursin(a2, packageText)

    if available && !commented
        packageEdited = foldl(replace,
                     (
                      a1 => "#"*a1,
                      a2 => "#"*a2,
                     ),
                     init = packageText)

                    file = open(packagePath,"w")
                    Base.write(file, packageEdited)
                    close(file)
        println("precompile is deactivated")
    elseif commented
        # do nothing
        println("precompile is already deactivated")
    else
        # TODO: add code automatiaclly
        error(""" add the following codes into your package:
         #include($precompilePath)
         #_precompile_()
         """)
    end

end
################################################################
"""
    BotConfig

Config object that holds the options and configuration for the snoopCompile bot. This object is fed to the `@snoopiBot`.
"""
struct BotConfig
    packageName::String
    blacklist::Vector{Union{AbstractString,Regex,AbstractChar}}
end

BotConfig(packageName::String) = BotConfig(packageName, String[])

################################################################
"""
    @snoopiBot config::BotConfig snoopScript

macro that generates precompile files and includes them in the package. Calls other bot functions.

# Examples

`@snoopiBot` the examples that call the package functions.

```julia
using SnoopCompile

@snoopiBot "MatLang" begin
  using MatLang
  examplePath = joinpath(dirname(dirname(pathof(MatLang))), "examples")
  include(joinpath(examplePath,"Language_Fundamentals", "usage_Entering_Commands.jl"))
  include(joinpath(examplePath,"Language_Fundamentals", "usage_Matrices_and_Arrays.jl"))
  include(joinpath(examplePath,"Language_Fundamentals", "Data_Types", "usage_Numeric_Types.jl"))
end
```
"""
macro snoopiBot(config::BotConfig, snoopScript)

    packageName = config.packageName
    blacklist= config.blacklist
    ################################################################
    packagePath = joinpath(pwd(),"src","$packageName.jl")
    precompilePath, precompileFolder = precompilePather(packageName)

    quote
        packageSym = Symbol($packageName)
        ################################################################
        using SnoopCompile
        ################################################################
        precompileDeactivator($packagePath, $precompilePath);
        ################################################################

        ### Log the compiles
        data = @snoopi begin
            $(esc(snoopScript))
        end

        ################################################################
        ### Parse the compiles and generate precompilation scripts
        pc = SnoopCompile.parcel(data, blacklist = $blacklist)
        onlypackage = Dict( packageSym => sort(pc[packageSym]) )
        SnoopCompile.write($precompileFolder,onlypackage)
        ################################################################
        precompileActivator($packagePath, $precompilePath)
    end

end

macro snoopiBot(packageName::String, snoopScript)
    config = BotConfig(packageName)
    return quote
        @snoopiBot $config $(esc(snoopScript))
    end
end
macro snoopiBot(configExpr, snoopScript)
    config = eval(configExpr)
    return quote
        @snoopiBot $config $(esc(snoopScript))
    end
end

"""
    @snoopiBot config::BotConfig

If you do not have additional examples, you can use your runtests.jl file. To do that use:

```julia
using SnoopCompile

# using runtests:
@snoopiBot "MatLang"
```
"""
macro snoopiBot(config::BotConfig)

    packageName = config.packageName

    package = Symbol(packageName)
    snoopScript = esc(quote
        using $(package)
        runtestpath = joinpath(dirname(dirname(pathof( $package ))), "test", "runtests.jl")
        include(runtestpath)
    end)
    return quote
        @snoopiBot $config $(esc(snoopScript))
    end
end

macro snoopiBot(packageName::String)
    config = BotConfig(packageName)
    return quote
        @snoopiBot $config
    end
end

macro snoopiBot(configExpr)
    config = eval(configExpr)
    return quote
        @snoopiBot $config
    end
end

################################################################
import Pkg
"""
Should be removed once Pkg allows adding test dependencies to the current environment

Used in workflow file
"""
function addtestdep()
    local testToml
    try
        testToml = Pkg.Types.parse_toml("test/Test.toml")
    catch
        error("please add a Test.toml to the /test directory for test dependencies")
    end

    for (name, uuid) in testToml["deps"]
        Pkg.add(Pkg.PackageSpec(name = name, uuid = uuid))
    end
end
################################################################
"""
    timesum(snoop)

Calculates and prints the total time measured by a snoop macro. It is used inside @snoopiBenchBot.

Julia can cache inference results so to measure the effect of adding _precompile_() sentences generated by snoopi to your package, use the [`@snoopiBenchBot`](@ref). This benchmark measures inference time taken during loading and running of a package.


## Manually benchmarking withtout using [`@snoopiBenchBot`](@ref)
- dev your package

- comment the precompile part of your package (`include()` and `_precompile_()`)
- run the following benchmark
- restart Julia

- uncomment the precompile part of your package (`include()` and `_precompile_()`)
- run the following benchmark
- restart Julia

### Benchmark
```julia
using SnoopCompile

println("Package load time:")
loadSnoop = @snoopi using MatLang

timesum(loadSnoop)

println("Running Examples/Tests:")
runSnoop = @snoopi begin
    using MatLang
    include(joinpath(dirname(dirname(pathof(MatLang))),"test","runtests.jl"))
end

timesum(runSnoop)
```
"""
function timesum(snoop::Vector{Tuple{Float64, Core.MethodInstance}})
    if isempty(snoop)
        return 0.0
    else
        return sum(first, snoop)
    end
end

################################################################
"""
    @snoopiBenchBot(packageName::String, snoopScript::Expr)
    @snoopiBenchBot(packageName::String)

Performs an infertime benchmark by activating and deactivating the __precompile__()
# Examples
Benchmarking the load infer time
```julia
println("loading infer benchmark")

@snoopiBenchBot "MatLang" using MatLang
```

Benchmarking the example infer time
```julia
println("examples infer benchmark")

@snoopiBenchBot "MatLang" begin
    using MatLang
    examplePath = joinpath(dirname(dirname(pathof(MatLang))), "examples")
    # include(joinpath(examplePath,"Language_Fundamentals", "usage_Entering_Commands.jl"))
    include(joinpath(examplePath,"Language_Fundamentals", "usage_Matrices_and_Arrays.jl"))
    include(joinpath(examplePath,"Language_Fundamentals", "Data_Types", "usage_Numeric_Types.jl"))
end
```

Benchmarking the tests:
```julia
@snoopiBenchBot "MatLang"
```
"""
macro snoopiBenchBot(packageName::String, snoopScript::Expr)

    ################################################################
    packagePath = joinpath(pwd(),"src","$packageName.jl")
    precompilePath, precompileFolder = precompilePather(packageName)

    juliaCode = """
    using SnoopCompile; data = @snoopi begin
        $(string(snoopScript));
    end;
    println(timesum(data));
    """
    juliaCmd = `julia --project=@. -e "$juliaCode"`
    quote
        packageSym = Symbol($packageName)
        ################################################################
        using SnoopCompile
        println("""*******************
        Benchmark Started
        *******************
        """)
        ################################################################
        println("""Precompile Deactivated Benchmark
        ------------------------
        """)
        precompileDeactivator($packagePath, $precompilePath);
        ### Log the compiles
        run($juliaCmd)
        ################################################################
        println("""Precompile Activated Benchmark
        ------------------------
        """)
        precompileActivator($packagePath, $precompilePath)
        ### Log the compiles
        run($juliaCmd)
        println("""*******************
        Benchmark Finished
        *******************
        """)
    end

end

macro snoopiBenchBot(packageName::String)
    package = Symbol(packageName)
    snoopScript = :(
        using $(package);
        runtestpath = joinpath(dirname(dirname(pathof($(package)))), "test", "runtests.jl");
        include(runtestpath);
    )
    return quote
        @snoopiBenchBot $packageName $(snoopScript)
    end
end
