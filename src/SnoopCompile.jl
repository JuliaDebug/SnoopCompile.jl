module SnoopCompile

using Serialization

export timesum  # @snoopi and @snoopc are exported from their files of definition

const anonrex = r"#{1,2}\d+#{1,2}\d+"         # detect anonymous functions
const kwrex = r"^#kw##(.*)$|^#([^#]*)##kw$"   # detect keyword-supplying functions
const kwbodyrex = r"^##(\w[^#]*)#\d+"         # detect keyword body methods
const genrex = r"^##s\d+#\d+$"                # detect generators for @generated functions
const innerrex = r"^#[^#]+#\d+"               # detect inner functions

if VERSION >= v"1.2.0-DEV.573"
    include("snoopi.jl")
    include("parcel_snoopi.jl")
end
include("snoopc.jl")
include("parcel_snoopc.jl")

include("write.jl")

"""
    timesum(snoop)

Calculates and prints the total time measured by a snoop macro

# Examples
Julia can cache inference results so to measure the effect of adding _precompile_() sentences generated by snoopi to your package, use the fllowing benchmark. This benchmark measures inference time taken during loading and running of a package.
- dev your package

- comment the precompile part of your package (`include()` and `_precompile_()`)
- run the following benchmark
- restart Julia

- uncomment the precompile part of your package (`include()` and `_precompile_()`)
- run the following benchmark
- restart Julia

## Benchmark
```julia
using SnoopCompile

println("Package load time:")
loadSnoop = @snoopi using MatLang

timesum(loadSnoop)

println("Running Examples/Tests:")
runSnoop = @snoopi begin
    using MatLang
    include(joinpath(dirname(dirname(pathof(MatLang))),"test","runtests.jl"))
end

timesum(runSnoop)
```
"""
function timesum(snoop::Vector{Tuple{Float64, Core.MethodInstance}})
    if isempty(snoop)
        return 0.0
    else
        return sum(first, snoop)
    end
end

end # module
